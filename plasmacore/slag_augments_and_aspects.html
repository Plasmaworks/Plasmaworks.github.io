<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Content generated by Mediawiki and mw2html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15.1" />
		<meta name="keywords" content="Slag:Augments and Aspects" />
		<link rel="shortcut icon" href="http://plasmaworks.com/sites/default/files/sky_favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="Plasmaworks (en)" />
		<link rel="alternate" type="application/rss+xml" title="Plasmaworks RSS Feed" href="" />
		<link rel="alternate" type="application/atom+xml" title="Plasmaworks Atom Feed" href="" />
		<title>Slag:Augments and Aspects - Plasmaworks</title>
		<link rel="stylesheet" href="shared.css" type="text/css" media="screen" />
		<link rel="stylesheet" href="commonprint.css" type="text/css" media="print" />
		<link rel="stylesheet" href="main.css" type="text/css" media="screen" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="ie50fixes.css" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="ie55fixes.css" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="ie60fixes.css" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="ie70fixes.css" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="" type="text/css" />
		<link rel="stylesheet" href="" type="text/css" media="print" />
		<link rel="stylesheet" href="" type="text/css" />
		<link rel="stylesheet" href="" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="iefixes.js_207"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/wiki/skins";
		var wgArticlePath = "/wiki/index.php/$1";
		var wgScriptPath = "/wiki";
		var wgScript = "/wiki/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://www.plasmaworks.com";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Slag:Augments_and_Aspects";
		var wgTitle = "Slag:Augments and Aspects";
		var wgAction = "view";
		var wgArticleId = "120";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 568;
		var wgVersion = "1.15.1";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="wikibits.js_207"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="ajax.js_207"></script>
		<script type="text/javascript" src=""><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Slag_Augments_and_Aspects skin-monobook">
	<div id="globalWrapperHacked">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 id="firstHeading" class="firstHeading">Slag:Augments and Aspects</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Plasmaworks</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p><i>Augments</i> are a way to achieve piece-wise class definitions in Slag.  You can write part of a class in the original definition and then add more methods and properties to it in a separate place with an augment.
</p><p><i>Aspects</i> are like Java interfaces that can include properties and method definitions (code).  They have a set of rules that allow aspect code to either replace or merge with existing code.
</p><p><br />
</p>
<table id="toc" class="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Augments"><span class="tocnumber">1</span> <span class="toctext">Augments</span></a>
<ul>
<li class="toclevel-2"><a href="#Model.2FView_Separation_Example"><span class="tocnumber">1.1</span> <span class="toctext">Model/View Separation Example</span></a></li>
<li class="toclevel-2"><a href="#Notes"><span class="tocnumber">1.2</span> <span class="toctext">Notes</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Aspects"><span class="tocnumber">2</span> <span class="toctext">Aspects</span></a>
<ul>
<li class="toclevel-2"><a href="#Basics"><span class="tocnumber">2.1</span> <span class="toctext">Basics</span></a>
<ul>
<li class="toclevel-3"><a href="#Dice_Example_v1"><span class="tocnumber">2.1.1</span> <span class="toctext">Dice Example v1</span></a></li>
<li class="toclevel-3"><a href="#Dice_Example_v2"><span class="tocnumber">2.1.2</span> <span class="toctext">Dice Example v2</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Aspects_With_Code"><span class="tocnumber">2.2</span> <span class="toctext">Aspects With Code</span></a>
<ul>
<li class="toclevel-3"><a href="#EventListener_Example_v1"><span class="tocnumber">2.2.1</span> <span class="toctext">EventListener Example v1</span></a></li>
<li class="toclevel-3"><a href="#EventListener_Example_v2"><span class="tocnumber">2.2.2</span> <span class="toctext">EventListener Example v2</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Underlying_and_Overlaying_Aspect_Methods"><span class="tocnumber">2.3</span> <span class="toctext">Underlying and Overlaying Aspect Methods</span></a></li>
<li class="toclevel-2"><a href="#Aspect_Layering"><span class="tocnumber">2.4</span> <span class="toctext">Aspect Layering</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Overlaying_Augments"><span class="tocnumber">3</span> <span class="toctext">Overlaying Augments</span></a></li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<a name="Augments" id="Augments"></a><h2> <span class="mw-headline"> Augments </span></h2>
<a name="Model.2FView_Separation_Example" id="Model.2FView_Separation_Example"></a><h3> <span class="mw-headline"> Model/View Separation Example </span></h3>
<pre> class Actor( Vector2 position, Vector2 velocity )
   method update: println( "updating actor" )
 endClass
 ...
 augment Actor
   method draw:  println( "drawing actor" )
 endAugment
 ...
 local Actor actor(pos,v)
 actor.update
 actor.draw
</pre>
<p><br />
</p>
<a name="Notes" id="Notes"></a><h3> <span class="mw-headline"> Notes </span></h3>
<ul><li> Defining properties and methods in an augment has the same effect as defining them in the original class.
</li></ul>
<ul><li> You may not redefine existing methods in an augment - however, that's possible with <a href="#Overlaying_Augments" title="">#Overlaying Augments</a>.
</li></ul>
<ul><li> For some templated class DataBank&lt;&lt;$DataType&gt;&gt;:
</li></ul>
<ul><li><ul><li> "augment DataBank" applies the augment to all template instances.
</li><li> "augment DataBank&lt;&lt;String&gt;&gt;" only applies the augment to the template instance specialized with type String.
</li><li> "augment DataBank&lt;&lt;primitive&gt;&gt;" only applies the augment to template instances specialized with a primitive datatype.
</li><li> <i>primitive</i> in the example above can be the following:
<ul><li> primitive - Any primitive data type (Real64, Real32, Int64, Int32, Char, Byte, Logical)
</li><li> numerical - Any primitive except Logical
</li><li> real      - Real64 or Real32
</li><li> integer   - Int64 or Int32
</li><li> compound  - Any compound type
</li><li> reference - Any reference type (object type)
</li><li> * - Any type (e.g. "augment TileMap&lt;&lt;*,primitive&gt;&gt;")
</li><li> non-primitive
</li><li> non-numerical
</li><li> non-real
</li><li> non-integer
</li><li> non-compound
</li><li> non-reference
</li></ul>
</li></ul>
</li></ul>
<p><br />
</p>
<a name="Aspects" id="Aspects"></a><h2> <span class="mw-headline"> Aspects </span></h2>
<a name="Basics" id="Basics"></a><h3> <span class="mw-headline"> Basics </span></h3>
<ul><li> Aspects are a way to allow a class to have multiple types.
</li><li> They are similar to Java interfaces except that they can include new properties and actual code.
</li><li> Where Java classes <i>implement interfaces</i>, Slag classes <i>incorporate aspects</i>.
</li><li> A variable of a given aspect type can reference any object that incorporates that aspect.
</li></ul>
<a name="Dice_Example_v1" id="Dice_Example_v1"></a><h4> <span class="mw-headline"> Dice Example v1 </span></h4>
<p>Consider the following code:
</p>
<pre> class RollTest1
   method init:
     local Die d6(6)
     local Die d4(4)
     println( d6.roll )  # prints: 1..6
     println( d4.roll )  # prints: 1..4
 
     local Dice attacker(), defender()
     attacker.add(d6,d6)
     defender.add(d4,d4,d4)
     println( attacker.roll )  # prints: 2..12
     println( defender.roll )  # prints: 3..12
 endClass
    
 class Die( Int32 sides )
   method roll.Int32:
     return random_Int32(1,sides)
 endClass
 
 class Dice()
   PROPERTIES
     dice()&nbsp;: Die[]
   
   METHODS
     method add( Die d ).Dice:
       # Note: methods that return their own class type allow automatic
       # call chaining, where writing add(a,b,c) translates into
       # add(a).add(b).add(c).
       dice.add(d)
       return this
 
     method roll.Int32:
       local var sum = 0
       forEach (d in dice) sum += d.roll
       return sum
 endClass
</pre>
<p>A Dice object stores a list of Die objects.  Both Dice and Die can have roll().Int32 called on them.  What would it take to allow a Dice object to store other Dice objects as well as individual Die objects?
</p><p>Die and Dice would have to have a common base class that defines <i>roll()</i>, but a Dice <i>is not</i> a Die and a Die <i>is not</i> a Dice so regular inheritance doesn't make sense.  However, both Die and Dice are rollable so we can make that a common aspect that both classes share.
</p>
<a name="Dice_Example_v2" id="Dice_Example_v2"></a><h4> <span class="mw-headline"> Dice Example v2 </span></h4>
<p>We'll define aspect Rollable as something that has a <i>roll()</i> method.  We'll incorporate that aspect into both Die and Dice classes, and finally we'll have class Dice store a list of Rollable objects which will let it store either single Die objects or Dice objects because now a Die object <i>is a</i> Rollable and a Dice object <i>is a</i> rollable.
</p>
<pre> class RollTest2
   method init:
     local Dice dice_2d6(), dice_2d6_d4()
     dice_2d6.add(Die(6),Die(6))
     dice_2d6_d4.add( dice_2d6 )
     dice_2d6_d4.add( Die(4) )
     println( dice_2d6_d4.roll ) # prints: 3..16
 endClass
    
 aspect Rollable
   method roll.Int32: abstract
 endAspect
 
 class Die( Int32 sides )&nbsp;: Rollable
   method roll.Int32:
     return random_Int32(1,sides)
 endClass
 
 class Dice()&nbsp;: Rollable
   PROPERTIES
     dice()&nbsp;: Rollable[]
   
   METHODS
     method add( Rollable d ).Dice:
       dice.add(d)
       return this
 
     method roll.Int32:
       local var sum = 0
       forEach (d in dice) sum += d.roll
       return sum
 endClass
</pre>
<p><br />
</p>
<a name="Aspects_With_Code" id="Aspects_With_Code"></a><h3> <span class="mw-headline"> Aspects With Code </span></h3>
<p>Aspect methods may include code as a default definition that can be redefined in the class.
</p>
<a name="EventListener_Example_v1" id="EventListener_Example_v1"></a><h4> <span class="mw-headline"> EventListener Example v1 </span></h4>
<p>In the example below, an "EventListener" has multiple methods with default definitions.  Two extended classes each redefine a different one of those methods.  This is very similar to inheritance, but keep in mind that "AlphaListener" and "BetaListener" both extend class object and only <i>incorporate</i> EventListener.  The important differences will explained a little later on.
</p>
<pre> class Test
   method init:
     local EventListener[] listeners()
     listeners.add( AlphaListener(), BetaListener() )
 
     forEach (listener in listeners) listener.on_alpha
       # prints:
       #   AlphaListener on_alpha!
       #   EventListener on_alpha!
 
     forEach (listener in listeners) listener.on_beta
       # prints:
       #   EventListener on beta!
       #   BetaListener on_beta!
 endClass
 
 aspect EventListener
   method on_alpha:  println( "EventListener on_alpha!" )
   method on_beta:   println( "EventListener on beta!" )
 endAspect
 
 class AlphaListener()&nbsp;: EventListener
   method on_alpha:  println( "AlphaListener on_alpha!" )
 endClass
 
 class BetaListener()&nbsp;: EventListener
   method on_beta:  println( "BetaListener on_beta!" )
 endClass
</pre>
<p><br />
</p>
<a name="EventListener_Example_v2" id="EventListener_Example_v2"></a><h4> <span class="mw-headline"> EventListener Example v2 </span></h4>
<p>When you redefine an aspect method you can include the original definition as well by writing "insertUnderlying".  In the modified example below, the redefined event callbacks each print something and include the original definition as well:
</p>
<pre> class Test
   method init:
     local EventListener[] listeners()
     listeners.add( AlphaListener(), BetaListener() )
 
     forEach (listener in listeners) listener.on_alpha
       # prints:
       #   AlphaListener on_alpha!  (AlphaListener)
       #   EventListener on_alpha!  (AlphaListener)
       #   EventListener on_alpha!  (BetaListener)
 
     forEach (listener in listeners) listener.on_beta
       # prints:
       #   EventListener on beta! (AlphaListener)
       #   EventListener on_beta  (BetaListener)
       #   BetaListener on_beta!  (BetaListener)
 endClass
 
 aspect EventListener
   method on_alpha:  println( "EventListener on_alpha!" )
   method on_beta:   println( "EventListener on beta!" )
 endAspect
 
 class AlphaListener()&nbsp;: EventListener
   method on_alpha:  println( "AlphaListener on_alpha!" ); insertUnderlying
 endClass
 
 class BetaListener()&nbsp;: EventListener
   method on_beta:  insertUnderlying; println( "BetaListener on_beta!" )
 endClass
</pre>
<p><br />
</p>
<a name="Underlying_and_Overlaying_Aspect_Methods" id="Underlying_and_Overlaying_Aspect_Methods"></a><h3> <span class="mw-headline"> Underlying and Overlaying Aspect Methods </span></h3>
<p>Aspect methods can be <i>underlying</i> (the default setting) or <i>overlaying</i>, which determines which method definition replaces which when there are multiple definitions.  Underlying methods are useful as default implementations and overlaying methods are useful for adding an extra bit of code to the beginning or end of a method definition.
</p><p>A toy example:
</p>
<pre> class Dishes&nbsp;: Mexican, FruitSnack, SpringMix
   method init:
     grapes
     salad
     beans
     peaches
 
     # prints:
     #   Grapes
     #   Spring Mix
     #     with Italian dressing
     #   Burritos
     #   Peaches
     #     and Cream
 
   method salad:
     insertUnderlying
     println( "  with Italian dressing" )
 
   method beans:
     println( "Beans" )
 
   method peaches:
     println( "Peaches" )
 endClass
 
 
 aspect SpringMix
   method salad:
     println( "Spring Mix" )
 endAspect
 
 
 overlaying aspect Mexican
   method beans:
     println( "Burritos" )
 endAspect
 
 
 aspect FruitSnack
   method grapes:
     println( "Grapes" )
 
   overlaying method peaches:
     insertUnderlying
     println( "  and Cream" )
 endAspect
</pre>
<p><br />
</p>
<a name="Aspect_Layering" id="Aspect_Layering"></a><h3> <span class="mw-headline"> Aspect Layering </span></h3>
<p>You can incorporate as many aspects into a class as you like.  In cases where there are multiple definitions of the same method, the following rules govern which methods are the "top-level" methods.
</p><p>For this class declaration:
</p>
<pre> class Alpha ...
 aspect Aspect1 ...
 aspect Aspect2 ...
 ...
 class Beta&nbsp;: Aspect1, Alpha, Aspect2
</pre>
<p>The methods are layered in the following order:
</p>
<ul><li> Overlaying methods from Aspect2 (topmost)
</li><li> Overlaying methods from Aspect1
</li><li> Methods defined in Beta
</li><li> Underlying methods from Aspect2
</li><li> Underlying methods from Aspect1
</li><li> Methods inherited from Alpha (bottommost)
</li></ul>
<p>Notes:
</p>
<ul><li> The order you incorporate aspects matters but where you list the base class doesn't matter.
</li></ul>
<ul><li> If an overlaying method in Aspect2 contains an "insertUnderlying" command, the code from the same method in "Aspect1" will be merged (if defined) and so on.
</li></ul>
<ul><li> If there is no underlying code in a call to <i>insertUnderlying</i> then nothing is inserted - you can add <i>insertUnderlying</i> without knowing or caring if there actually is underlying code.
</li></ul>
<ul><li> When <i>insertUnderlying</i> would insert a method inherited from the base class, insertUnderlying is turned into a prior call instead ("method update: insertUnderlying" -&gt; "method update: prior.update").
</li></ul>
<ul><li> Merging aspect methods creates a single method containing all of the merged code.
</li></ul>
<ul><li> Consider the following: "method update: println("pt1"); insertUnderlying; println("pt2")".  If the underlying code contains a <i>return</i> command, the method will end without "pt2" ever having a chance to print out.  For this reason the standard approach to writing overlaying code should be to perform all your tasks first and <i>then</i> call <i>insertUnderlying</i>.
</li></ul>
<p><br />
</p>
<a name="Overlaying_Augments" id="Overlaying_Augments"></a><h2> <span class="mw-headline"> Overlaying Augments </span></h2>
<p>A common design pattern in Slag is to augment a class (often a library class someone else wrote) to incorporate an aspect which changes the behavior of a method, like so:
</p>
<pre> overlaying aspect SubstringTrace
   method substring( Int32 first_index, Int32 last_index ).String:
     println( "DEBUG: substring indices are $..$" (first_index,last_index) )
     insertUnderlying
 endAspect
 
 augment String&nbsp;: SubstringTrace;
</pre>
<p>An <i>overlaying augment</i> is a shorthand notation for accomplishing the same thing:
</p>
<pre> overlaying augment String
   method substring( Int32 first_index, Int32 last_index ).String:
     println( "DEBUG: substring indices are $..$" (first_index,last_index) )
     insertUnderlying
 endAugment
</pre>
<!-- 
NewPP limit report
Preprocessor node count: 14/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key pw_mediawiki_user:pcache:idhash:120-0!1!0!!en!2!edit=0 and timestamp 20120628120357 -->
<div class="printfooter">
Retrieved from "<a href="">http://www.plasmaworks.com/wiki/index.php/Slag:Augments_and_Aspects</a>"</div>
						<!-- end content --><div class="visualClear"></div></div></div></div>
    <div id="column-one">
      <div id="p-cactions" class="portlet"></div>
      <div class="portlet" id="p-personal"></div>
      <div class="portlet" id="p-logo"></div>
      <div class="portlet" id="p-nav">
  
      </div>
      <div id="p-search" class="portlet"></div>
      <div class="portlet" id="p-tb"></div>
    </div>
    <!-- end left column -->
  <!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footerHacked">
				<ul id="f-list">
					<li id="lastmod"> This page was last modified on 11 May 2010, at 22:33.</li>
					<li id="viewcount">This page has been accessed 1,571 times.</li>
					<li id="privacy"><a href="plasmaworks_privacy_policy.html" title="Plasmaworks:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="plasmaworks_about.html" title="Plasmaworks:About">About Plasmaworks</a></li>
					<li id="disclaimer"><a href="plasmaworks_general_disclaimer.html" title="Plasmaworks:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.289 secs. --><br></body></html>
