#=====================================================================
# plasmacore.slag
#
# v2.16b - 2009.07.30
#
# --------------------------------------------------------------------
#
# Copyright 2009 Plasmaworks LLC
#
# Plasmacore is free for non-commercial use.  Commercial use requires
# a one-time license fee.  See the LICENSE file in the distribution 
# and/or visit this web site for more information:
#
#   http://www.plasmaworks.com/plasmacore
#
#=====================================================================


#=====================================================================
# System
#=====================================================================
augment System
  METHODS
    requisite method load_settings_data.Byte[]:
      local DataFile f("data/settings.txt")
      if (f.exists) return f.to_bytes
      return null
endAugment

class DataFile : File
  PROPERTIES
    is_gamestate : Logical
    data         : Char[]

  METHODS
    method init( filepath ):
      try
        data = ResourceManager.load_gamestate( filename );
        is_gamestate = true
      catch (FileError err)
        try
          data = ResourceManager.load_data_file( filepath );
        catch (FileError err2)
        endTry
      endTry

    method exists.Logical:
      # Returns whether or not this file already exists.
      return data?

    method size.Int32:
      # Returns the byte size of this file.  Throws a NullReferenceError
      # if the file does not exist.
      return data.count

    method create_reader.Reader<<Char>>:
      if (not data?) throw FileError()
      return data.create_reader

    method create_writer.PrintWriter:
      return DataFileWriter( this )

    method create_appender.PrintWriter:
      # Like write() but appends data to the file, if it exists,
      # rather than overwriting it.
      return DataFileWriter( this, data.(ArrayList<<Char>>) )

    method is_directory.Logical:
      return false

    method absolute_path.String:
      # Returns the absolute path denoted by this File object.
      return path

    method to_String.String:
      # Returns the original filepath of this File object.
      return filepath

    method absolute_filepath.String:
      return filepath

    method directory_listing.String[]:
      throw UnsupportedMethodError()
endClass

class DataFileWriter : StringBuilder
  PROPERTIES
    file : DataFile

  METHODS
    method init( file, data = Char[](80) ):

    method close:
      data.trim_to_count
      ResourceManager.save_gamestate( file.filename, data )
      file.data = data
      file.is_gamestate = true
endClass


#=====================================================================
# Application
#=====================================================================
requisite managed singleton class Application
  PROPERTIES
    display_size : readOnly Vector2
      # The display size in pixels.  In general use your main screen's 
      # "size" instead.

    bg_color=Color(0,0,0) : Color
      # The color the screen is automatically cleared to before each
      # call to draw().  If you set 'bg_color' to a color with zero
      # alpha the native layer will not clear the back buffer.

    clipping_region    : Box
      # The current viewport - parts of graphics that lie outside
      # this region are clipped and not drawn.

    logfile_path  : String
      # Internal use.

    logfile       : File
      # Internal use.

    stdout_logger : StdOutWriter
      # Internal use.

    trace_messages     : String[]
      # The list of active trace messages.

    last_trace_activity_ms : Int64
      # The time of the last new trace message.

    main_object_transform_stack  : Transform[]
    main_camera_transform_stack  : Transform[]
    offscreen_object_transform_stack(0) : Transform[]
    offscreen_camera_transform_stack(0) : Transform[]
    main_clipping_region : Box

  METHODS
    method init_object:

      # need to set this up first in case of error messages
      trace_messages = String[]()

      # Mechanism to ensure that Application singleton is set to
      # the extended class object if created.  E.g. if you create
      # MyGame() which extends Application, Application will be
      # set to the MyGame object.
      Application = this

      logfile_path = File("data/log.txt").absolute_filepath

    requisite method init:

    requisite method call_init( display_size ):
      try
        clipping_region = Box(display_size)
        init
        GUIManager.app_initialized = true
      catch (Error err)
        trace( err.to_String )
      endTry

    method title( String window_title ): native
      # Application title property-set for this application.
      #
      # Example:
      #   Application.window_title = "MadStone"

    method fullscreen.Logical: native
      # Returns "true" if the application is running in fullscreen 
      # mode or "false" if it's running in windowed mode.
      #
      # Example:
      #   if (Application.fullscreen) ...

    method fullscreen( Logical setting ): native
      # Sets the application to fullscreen if setting is "true" or 
      # windowed mode if it's "false".
      #
      # Example:
      #   Application.fullscreen = true

    method mouse_visible( Logical setting ): native
      # Property-set that specifies the visibility of the system 
      # mouse.  This is "true" by default.
      #
      # Example:
      #   Application.mouse_visible = false

    method input_capture( Logical setting ): native
      # Property-set that specifies whether input is captured by
      # (and restricted to) this application.  This is "false" by 
      # default.
      #
      # Example:
      #   Application.input_capture = true

    requisite method on_exit_request:
      # Called when the user attempts to close the app.  Calls
      # exit_program() by default.  
      #
      # Windows and Mac:
      # You can override this method to perform cleanup and/or postpone 
      # the call to exit_program at some later point. 
      #
      # iPhone:
      # You cannot prevent the application from exiting; use this
      # method to save game state in a file if desired.
      if (System.os != "iphone") System.exit_program

    requisite method on_toggle_fullscreen:
      # Called by the input object when an ALT+ENTER key combination
      # is detected.  The default behavior is to toggle the fullscreen
      # property setting.
      fullscreen = not fullscreen

    #method on_garbage_collection:
      # Called by the native layer whenever a garbage collection
      # has just happened.

    method trace( String mesg ):
      # Prints the given trace message to the screen as well as 
      # logging it to "log.txt".
      forEach (line in LineReader(mesg))
        trace_messages.add( line )
        log( line )
      endForEach

      while (trace_messages.count > 15) trace_messages.remove_first
      last_trace_activity_ms = time_ms

    method trace( Vector2 v ):
      # Traces 'v' as a text message.
      trace( to_String(v) )

    method log( String mesg ):
      # Prints the given message to stdout and "data/log.txt".
      if (not stdout_logger?)
        stdout_logger = StdOutWriter()
        if (System.os == "mac" or System.os == "windows")
          logfile = File(logfile_path)
          logfile.create_writer.close  # recreate log file
        endIf
      endIf

      stdout_logger.println( mesg )
      if (logfile?)
        local var logger = logfile.create_appender
        logger.println( mesg )
        logger.close
      endIf

    method log( Vector2 v ):
      # Logs 'v'.
      log( to_String(v) )

    method clipping_region( Box new_clip ):
      # This property-set adjust the clipping region of the screen.
      # Anything part of any graphics that lie outside the clipping 
      # region won't be drawn.  The current transform is applied
      # to the clipping coordinates - a non-orthagonal transform
      # will not be correctly applied.
      &clipping_region = new_clip
      native_set_clipping_region( new_clip )

    private method native_set_clipping_region( Box new_clip ): native

    method set_draw_target( OffscreenBuffer buffer, Logical blend_alpha=true ):
      # Selects the given offscreen buffer as the target of various drawing
      # commands - send "null" to change back to the main display. Send
      # "true" for 'blend_alpha' to perform normal alpha blending or "false"
      # to preserve the alpha of the original colors as they're drawn.
      native_set_draw_target( buffer, blend_alpha )
      if (buffer?)
        if (main_object_transform_stack isNot offscreen_object_transform_stack)
          main_object_transform_stack = Transform.object
          main_camera_transform_stack = Transform.camera
          offscreen_object_transform_stack.clear
          offscreen_camera_transform_stack.clear
          Transform.object = offscreen_object_transform_stack
          Transform.camera = offscreen_camera_transform_stack
          main_clipping_region = clipping_region
        endIf
      else
        if (main_object_transform_stack?)
          Transform.object = main_object_transform_stack
          Transform.camera = main_camera_transform_stack
          clipping_region = main_clipping_region
        endIf
      endIf

    private method native_set_draw_target( OffscreenBuffer buffer, Logical blend_alpha ): native
      # Selects the given OffscreenBuffer to be the target of image-drawing calls.
      # Pass "null" to use the main display as the draw target.  The draw target
      # is reset to the main display before each draw event.
      #
      # Example:
      #   status_bar(320,32) : OffscreenBuffer
      #   ...
      #   Application.set_draw_target(status_bar)
      #   tool_icon.draw( 0, 0 )
      #   ...
      #   Application.set_draw_target(null)  # select main display
      #   status_bar.draw( 0, 0 )
endClass


singleton class ApplicationManager
  PROPERTIES
    the_instance : Application

  METHODS
    method get.Application:
      return the_instance

    method set( Application app ):
      the_instance = app
endClass


augment Global
  SINGLETONS
    Application
endAugment


overlaying augment System
  METHODS
    method on_garbage_collection:
      GUIManager.on( SystemEvent(garbage_collected) )
endAugment


#=====================================================================
#  TraceWriter - used to redirect stdout messages to be a trace
#=====================================================================
requisite class TraceWriter : PrintWriter
  PROPERTIES
    buffer() : StringBuilder

  METHODS
    method init;

    method write( Char ch ):
      if (ch == 10)
        local var st = buffer.to_String
        trace( st )
        buffer.clear
      else
        buffer.print( ch )
      endIf
endClass

#=====================================================================
# Transform
#=====================================================================
compound TransformRow( Real64 c0, Real64 c1, Real64 c2 )

compound Transform( TransformRow r0, TransformRow r1 )
  # A 2x3 matrix (which is a 3x3 that ignores the last row)
  # that represents various combinations of transformations.

requisite singleton class TransformManager
  PROPERTIES
    object() : Transform[]
      # Object transformation stack.

    camera() : Transform[]
      # Camera transformation stack.

  METHODS
    method create_from.Transform: 
      # Creates a Tranform set up to be the identity matrix.
      return identity

    method create_from( Real64 r0c0, Real64 r0c1, Real64 r0c2,
                        Real64 r1c0, Real64 r1c1, Real64 r1c2 ).Transform:
      # Creates a 2x3 transform from arbitrary data.
      return Transform( TransformRow(r0c0,r0c1,r0c2), 
                        TransformRow(r1c0,r1c1,r1c2) )

    method create_from( Vector2 handle, Radians angle, Vector2 scale, Vector2 translation ).Transform:
      local Real64 hx = handle.x
      local Real64 hy = handle.y
      local Real64 sx = scale.x
      local Real64 sy = scale.y
      local Real64 cost = angle.cos
      local Real64 sint = angle.sin
      local Real64 tx = translation.x
      local Real64 ty = translation.y
      return Transform( TransformRow(cost*sx,-sint*sy,(tx-sx*hx*cost+sint*sy*hy)), 
                        TransformRow(sint*sx, cost*sy,(ty-sx*hx*sint-cost*sy*hy)) )

    method create_from( Radians angle, Vector2 scale, Vector2 translation ).Transform:
      local Real64 sx = scale.x
      local Real64 sy = scale.y
      local Real64 cost = angle.cos
      local Real64 sint = angle.sin
      local Real64 tx = translation.x
      local Real64 ty = translation.y
      return Transform( TransformRow(cost*sx,-sint*sy,(tx-sx*cost+sint*sy)), 
                        TransformRow(sint*sx, cost*sy,(ty-sx*sint-cost*sy)) )

    method local_to_screen.Transform: native
      # Multiplies out the camera transforms and the object transforms
      # and returns a final camera*object local-to-screen transform.
      # Results are cached; you can call this
      # method heavily if needed.

    method screen_to_local.Transform: native
      # Returns the inverse of the local_to_screen() matrix.  Like
      # that matrix, screen_to_local is cached and may be called heavily.

    method inverse.Transform: native

    method op*( Transform transform1, Transform transform2 ).Transform: native
      # Multiplies two transforms together.

    method identity.Transform:
      return Transform( TransformRow(1,0,0), TransformRow(0,1,0) )

    method rotate( Radians angle ).Transform:
      local Real64 cos_value = angle.cos
      local Real64 sin_value = angle.sin
      return Transform( TransformRow(cos_value,-sin_value,0), TransformRow(sin_value,cos_value,0) )

    method rotate( Degrees angle ).Transform:
      local Real64 cos_value = angle.cos
      local Real64 sin_value = angle.sin
      return Transform( TransformRow(cos_value,-sin_value,0), TransformRow(sin_value,cos_value,0) )

    method translate( Vector2 delta ).Transform:
      return Transform( TransformRow(1,0,delta.x), TransformRow(0,1,delta.y) )

    method translate( Real64 dx, Real64 dy ).Transform:
      return Transform( TransformRow(1,0,dx), TransformRow(0,1,dy) )

    method scale( Vector2 scale ).Transform:
      return Transform( TransformRow(scale.x,0,0), TransformRow(0,scale.y,0) )

    method scale( Real64 sx, Real64 sy ).Transform:
      return Transform( TransformRow(sx,0,0), TransformRow(0,sy,0) )

    method scale( Real64 s ).Transform:
      return Transform( TransformRow(s,0,0), TransformRow(0,s,0) )

    method to_String( Transform transform ).String:
      return "[$ $ $;\n $ $ $]" (transform.r0.c0, transform.r0.c1, transform.r0.c2,
          transform.r1.c0, transform.r1.c1, transform.r1.c2)

endClass

#=====================================================================
# Sound
#=====================================================================
class NativeSound : RequiresCleanup
  # Wrapper class for a native-layer sound effect.  Sound objects
  # don't contain the actual sound data, but instead store an index 
  # that the native layer uses to identify sounds.
  PROPERTIES
    native_resource : Int32
      # The index used to identify the associated sound between 
      # Plasmacore and the native layer.

  METHODS
    method init( String filename, Logical decode=void ): native

    method init( NativeSound existing ):
      local var dup = duplicate( existing )
      native_resource = dup.native_resource
      dup.native_resource = 0

    method init( Byte[] raw_bytes ): native

    method create_duplicate.NativeSound: native
      # Creates a duplicate of an existing sound that may be played,
      # paused, etc. separate from the original.  The actual sample
      # data is shared between the two so this is a low-overhead
      # action.

    method play:  native
    method pause: native

    method is_playing.Logical: native
    method volume( Real64 new_volume ): native
    method pan( Real64 speaker_pan ):   native
    method pitch( Real64 new_pitch ):   native
    method repeats( Logical setting ):  native
    method current_time().Real64:       native
    method current_time( Real64 new_time ): native
    method duration.Real64: native

    method clean_up:
      # Internal use.  Calls release().
      release

    method release: native
      # Releases the memory used by the associated native sound data 
      # in the hardware layer.  If this sound is the original of a 
      # concurrent sound set, all the associated concurrent sound 
      # duplicates are released as well.  May be called manually, but 
      # is also automatically called when this object has no more 
      # references.
endClass

class Sound
  # Manages a sound with a number of simultaneous channels.
  #
  # Example:
  #   bell_sound : Sound
  #   ...
  #   bell_sound = Sound( "bell", 3 )  # play up to three times simultaneously
  CLASS_PROPERTIES
    default_group() : SoundGroup

  CLASS_METHODS
    method audio_supported.Logical: native
      # Returns "true" if the computer running this application has
      # standard audio support.  If "false" the implication is that
      # each attempt at loading a sound will fail with a FileError.


  PROPERTIES
    channels : NativeSound[]

    volume=1.0 : Real64
      # Per-sound volume setting that is multiplied by the sound group's
      # master volume to determine the final volume.

    pan=0.0 : Real64
      # 0.0 [default] plays on both speakers
      # -1.0 plays on left speaker only.
      # 1.0 plays on right speaker only.
      #
      # Notes:
      # Adjusting the pan has no effect on the iPhone.

    pitch=1.0 : Real64
      # Valid values are 0.5 (half pitch) .. 2.0 (double pitch).
      #
      # Notes:
      # Adjusting the pitch has no effect on the iPhone.

    repeats : Logical

    group    : SoundGroup
      # The sound group that this sound belongs to.  Set to
      # 'default_group' when the sound is created.

  METHODS
    method init( String filename, Int32 num_channels=1, Logical decode=void ):
      # Loads a sound from the given file.  Sounds may be in WAV, OGG, FLAC,
      # MOD, or AIFF formats.
      #
      # Parameters:
      #   filename
      #     The file to be loaded.
      #
      #     The following variations of 'filename' are checked:
      #
      #       filename
      #       filename.ext  (.ext = [.ogg|.wav|.flac|.mod|.aiff])
      #       data/filename
      #       data/filename.ext
      #
      #   num_channels
      #     How many duplicates of this sound can be independently playing
      #     (default: 1).  Duplicates are low overhead because they 
      #     share the same sample data.
      #
      #   decode
      #     true
      #       File is loaded into memory as decoded raw PCM
      #       samples.  Requires more memory but less processor time 
      #       when playing.  Not recommended for longer pieces
      #       of music due to memory consumption!
      #
      #     false
      #       File is loaded into memory in its original 
      #       compressed/encoded format.  Requires less memory but
      #       more processor time when playing.
      #
      #     void [default]
      #       The system determines whether to decompress the file
      #       or not.  For PC and Mac, files less than 100K when 
      #       decompressed are decoded and larger ones are not.
      # 
      #     Notes: 'decode' has no effect on iPhone.
      init( NativeSound(filename,decode), num_channels )

    method init( NativeSound snd, Int32 num_channels=1 ):
      channels = NativeSound[](num_channels)
      channels.add( snd )
      forEach (2..num_channels) 
        channels.add( NativeSound(channels.first) )
      endForEach

      group = default_group
      if (group?) group.add( this )
      volume = volume # reset the volume to incorporate master volume

    method play:
      # If this sound has any paused channels those are resumed.
      # Otherwise if there is an unused channel, the sound is played
      # on that channel.

      local var found_paused = false
      forEach (channel in channels)
        if (not channel.is_playing and channel.current_time > 0) 
          channel.play
          found_paused = true
        endIf
      endForEach

      if (found_paused) return

      forEach (channel in channels)
        if (not channel.is_playing and channel.current_time == 0) channel.play; return
      endForEach

    method pause:
      # Pauses playback of this sound on all active channels.  
      # The playback can be resumed with play().
      forEach (channel in channels) channel.pause

    method stop:
      # Stops playback of this sound on all active channels.  
      pause
      current_time = Real64(0)

    method duration.Real64:
      # Returns the duration of this sound.
      return channels.first.duration

    method is_playing.Logical:
      # Returns "true" if this sound is currently playing any number of
      # channels or false if all channels are finished or paused.
      forEach (channel in channels)
        if (channel.is_playing) return true
      endForEach
      return false

    method is_paused.Logical:
      # Returns "true" if this sound has any paused channels.
      forEach (channel in channels)
        if (not channel.is_playing and channel.current_time > 0) return true
      endForEach
      return false

    method volume( Real64 new_volume ):
      # 'volume' property-set.
      &volume = new_volume
      if (group?)
        forEach (channel in channels)
          channel.volume = new_volume * group.master_volume
        endForEach
      endIf

    method pan( Real64 speaker_pan ):
      # 'pan' property-set.  -1.0=left speaker only, 1.0=right speaker only,
      # 0.0=both speakers.
      #
      # Notes:
      # No effect on iPhone.
      &pan = speaker_pan
      forEach (channel in channels)
        channel.pan = speaker_pan
      endForEach

    method pitch( Real64 new_pitch ):
      # 'pitch' property-set.  Valid values range from 0.5 to 2.0.
      #
      # Notes:
      # No effect on iPhone.
      &pitch = new_pitch
      forEach (channel in channels)
        channel.pitch = new_pitch
      endForEach

    method repeats( Logical setting ):
      # 'repeats' property-set.
      &repeats = setting
      forEach (channel in channels)
        channel.repeats = setting
      endForEach

    method current_time.Real64:
      # Returns the current playback position of the sound on
      # the first channel in seconds.
      return channels.first.current_time

    method current_time( Real64 new_time ):
      # Resets the current playback position of all channels to the given time
      # in seconds.
      forEach (channel in channels)
        channel.current_time = new_time
      endForEach

    method release:
      # Releases the memory used by the associated native sound data 
      # in the hardware layer.
      forEach (channel in channels)
        channel.release
      endForEach
      channels.clear
endClass


class SoundGroup
  # A collection of Sound objects that can be affected as a group
  # (collective play, pause, set_volume, etc.).  A sound group
  # also has a scaling master volume that affects the volumes of its 
  # collective sounds and is particularly useful for its release()
  # method that releases all its sounds in a single step.
  #
  # Each Sound is automatically added to Sound.default_group (if set) as 
  # it's created - you can change that to be a different sound group
  # at any time.
  PROPERTIES
    sounds()          : Sound[]
      # The sounds this object manages. 

    master_volume=1.0 : Real64
      # The volume multiplier for all sounds.

  METHODS
    method init:
      # Default initializer.

    method add( Sound s ):
      # Adds the given sound to this group.  Called automatically
      # by sound objects as they're created if Sound::default_group
      # is set.
      sounds.add( s )

    method resume:
      # Resumes playback of all sounds that are paused.  If no sounds
      # are paused then nothing happens.
      forEach (sound in sounds) 
        if (sound.is_paused) sound.play
      endForEach

    method pause:
      # Pauses all playing sounds.
      forEach (sound in sounds) sound.pause

    method stop:
      # Stops all sounds (including paused sounds).
      forEach (sound in sounds) sound.stop

    method any_playing.Logical:
      # Returns "true" if any sounds are playing.
      forEach (sound in sounds)
        if (sound.is_playing) return true
      endForEach
      return false

    method master_volume( Real64 new_master_volume ):
      # Resets the master volume and applies the new master volume 
      # to each sound.
      &master_volume = new_master_volume
      forEach (sound in sounds)
        # This volume re-set applies the new master volume
        sound.volume = sound.volume
      endForEach

    method volume( Real64 new_volume ):
      # Sets each sound to a new volume.  You may wish to change the
      # 'master_volume' instead.
      forEach (sound in sounds) sound.volume = new_volume

    method pan( Real64 new_pan ):
      # Sets each sound to have a new stereo pan.
      forEach (sound in sounds) sound.pan = new_pan

    method pitch( Real64 new_pitch ):
      # Sets each sound to have a new pitch shift
      forEach (sound in sounds) sound.pitch = new_pitch

    method repeats( Logical setting ):
      # Sets each sound to have a new 'repeats' value.
      forEach (sound in sounds) sound.repeats = setting

    method release:
      # Releases all sounds (they may no longer be played) and 
      # clears the list of sounds.
      forEach (sound in sounds) sound.release
      sounds.clear

    method clear:
      # Removes all sounds from this group.  If you are finished
      # with the sounds you should call release() instead.
      sounds.clear
endClass

#=====================================================================
# InputListener
#=====================================================================

underlying aspect InputListener
  # Defines the methods of a InputListener that receives input events.
  METHODS
    method on( KeyEvent event );

    method on( MouseEvent event );

    method on( JoystickEvent event );

    method on( AccelerationEvent event );

    method on( SystemEvent event ):

    overlaying method listen_to( DispatcherType dispatcher ):
      # Instructs this InputListener to listen to the given 
      # dispatcher.
      underlying( dispatcher )
      if (dispatcher instanceOf InputDispatcher)
        dispatcher.(InputDispatcher).input_listeners.add( this )
      endIf

    overlaying method stop_listening_to( DispatcherType dispatcher ):
      # Stops this InputListener from listening to the given 
      # dispatcher.
      underlying( dispatcher )
      if (dispatcher instanceOf InputDispatcher)
        dispatcher.(InputDispatcher).input_listeners.remove( this )
      endIf
endAspect


#=====================================================================
# InputDispatcher
#=====================================================================
underlying aspect InputDispatcher : DispatcherType
  # Defines the methods of an input dispatcher.
  PROPERTIES
    input_listeners(1) : InputListener[]
      # List of key listeners receiving events from this dispatcher.

    active_input_listeners(1) : InputListener[]
      # Work list - internal use.

  METHODS
    method dispatch( KeyEvent event ):
      # Sends the given key event to all registered listeners.
      forEach (listener in active_input_listeners.copy_from(input_listeners))
        listener.on( event )
      endForEach

    method dispatch( MouseEvent event ):
      # Sends the given mouse event to all registered listeners.
      forEach (listener in active_input_listeners.copy_from(input_listeners))
        listener.on( event )
      endForEach

    method dispatch( JoystickEvent event ):
      # Sends the given joystick event to all registered listeners.
      forEach (listener in active_input_listeners.copy_from(input_listeners))
        listener.on( event )
      endForEach

    method dispatch( AccelerationEvent event ):
      # Sends the given acceleration event to all registered listeners.
      forEach (listener in active_input_listeners.copy_from(input_listeners))
        listener.on( event )
      endForEach

    method dispatch( SystemEvent event ):
      # Sends the given system event to all registered listeners.
      forEach (listener in active_input_listeners.copy_from(input_listeners))
        listener.on( event )
      endForEach
endAspect



#=====================================================================
# KeyEvent
#=====================================================================

compound KeyEvent( Int32 type, Int32 keycode, Char unicode, Int32 modifiers )
  # Contains information about a given key event.
  #
  # Parameters:
  #   type
  #     One of: KeyEvent.press, repeat, release
  #
  #   keycode
  #     The raw keycode of the key pressed - Key.keycode_a,
  #     Key.keycode_0, etc.  Corresponds to SDL keycode values.
  #
  #   unicode
  #     The unicode value of the key pressed - 'A', '0', etc.
  #
  #   modifiers
  #     Flags indicating what key modifiers were pressed at the time
  #     of the key event.  Use the following methods to check:
  #
  #       event.shift_pressed
  #       event.ctrl_pressed
  #       event.alt_pressed
  #       event.caps_locked

singleton class KeyEventManager
  PROPERTIES
    release = 0 : Int32
    press   = 1 : Int32
    repeat  = 2 : Int32

  METHODS
    method shift_pressed( KeyEvent event ).Logical:
      return (event.modifiers & Key.modifier_shift) != 0

    method ctrl_pressed( KeyEvent event ).Logical:
      return (event.modifiers & Key.modifier_ctrl) != 0

    method alt_pressed( KeyEvent event ).Logical:
      return (event.modifiers & Key.modifier_alt) != 0

    method caps_locked( KeyEvent event ).Logical:
      return (event.modifiers & Key.modifier_caps_lock) != 0
endClass



singleton class Key
  # A collection of key constants.
  PROPERTIES
    modifier_shift     =  1 : Int32
    modifier_ctrl      =  2 : Int32
    modifier_alt       =  4 : Int32
    modifier_caps_lock =  8 : Int32
    
    keycode_backspace     =   8 : Int32
    keycode_tab           =   9 : Int32
    keycode_enter         =  13 : Int32
    keycode_pause         =  19 : Int32
    keycode_escape        =  27 : Int32

    keycode_space         =  32 : Int32
    keycode_exclaim       =  33 : Int32
    keycode_quote         =  34 : Int32
    keycode_hash          =  35 : Int32
    keycode_dollar        =  36 : Int32
    keycode_ampersand     =  38 : Int32
    keycode_apostrophe    =  39 : Int32
    keycode_left_paren    =  40 : Int32
    keycode_right_paren   =  41 : Int32
    keycode_asterisk      =  42 : Int32
    keycode_plus          =  43 : Int32
    keycode_comma         =  44 : Int32
    keycode_minus         =  45 : Int32
    keycode_period        =  46 : Int32
    keycode_slash         =  47 : Int32
    keycode_0             =  48 : Int32
    keycode_1             =  49 : Int32
    keycode_2             =  50 : Int32
    keycode_3             =  51 : Int32
    keycode_4             =  52 : Int32
    keycode_5             =  53 : Int32
    keycode_6             =  54 : Int32
    keycode_7             =  55 : Int32
    keycode_8             =  56 : Int32
    keycode_9             =  57 : Int32
    keycode_colon         =  58 : Int32
    keycode_semicolon     =  59 : Int32
    keycode_less          =  60 : Int32
    keycode_equals        =  61 : Int32
    keycode_greater       =  62 : Int32
    keycode_question      =  63 : Int32
    keycode_at            =  64 : Int32
    keycode_left_bracket  =  91 : Int32
    keycode_backslash     =  92 : Int32
    keycode_right_bracket =  93 : Int32
    keycode_circumflex    =  94 : Int32
    keycode_underline     =  95 : Int32
    keycode_grave         =  96 : Int32
    keycode_a             =  97 : Int32
    keycode_b             =  98 : Int32
    keycode_c             =  99 : Int32
    keycode_d             = 100 : Int32
    keycode_e             = 101 : Int32
    keycode_f             = 102 : Int32
    keycode_g             = 103 : Int32
    keycode_h             = 104 : Int32
    keycode_i             = 105 : Int32
    keycode_j             = 106 : Int32
    keycode_k             = 107 : Int32
    keycode_l             = 108 : Int32
    keycode_m             = 109 : Int32
    keycode_n             = 110 : Int32
    keycode_o             = 111 : Int32
    keycode_p             = 112 : Int32
    keycode_q             = 113 : Int32
    keycode_r             = 114 : Int32
    keycode_s             = 115 : Int32
    keycode_t             = 116 : Int32
    keycode_u             = 117 : Int32
    keycode_v             = 118 : Int32
    keycode_w             = 119 : Int32
    keycode_x             = 120 : Int32
    keycode_y             = 121 : Int32
    keycode_z             = 122 : Int32
    keycode_delete        = 127 : Int32
    keycode_numpad_0      = 256 : Int32
    keycode_numpad_1      = 257 : Int32
    keycode_numpad_2      = 258 : Int32
    keycode_numpad_3      = 259 : Int32
    keycode_numpad_4      = 260 : Int32
    keycode_numpad_5      = 261 : Int32
    keycode_numpad_6      = 262 : Int32
    keycode_numpad_7      = 263 : Int32
    keycode_numpad_8      = 264 : Int32
    keycode_numpad_9      = 265 : Int32
    keycode_numpad_period = 266 : Int32
    keycode_numpad_slash  = 267 : Int32
    keycode_numpad_star   = 268 : Int32
    keycode_numpad_minus  = 269 : Int32
    keycode_numpad_plus   = 270 : Int32
    keycode_numpad_enter  = 271 : Int32
    keycode_numpad_equals = 272 : Int32

    keycode_up_arrow      = 273 : Int32
    keycode_down_arrow    = 274 : Int32
    keycode_right_arrow   = 275 : Int32
    keycode_left_arrow    = 276 : Int32
    keycode_insert        = 277 : Int32
    keycode_home          = 278 : Int32
    keycode_end           = 279 : Int32
    keycode_page_up       = 280 : Int32
    keycode_page_down     = 281 : Int32
    keycode_f1            = 282 : Int32
    keycode_f2            = 283 : Int32
    keycode_f3            = 284 : Int32
    keycode_f4            = 285 : Int32
    keycode_f5            = 286 : Int32
    keycode_f6            = 287 : Int32
    keycode_f7            = 288 : Int32
    keycode_f8            = 289 : Int32
    keycode_f9            = 290 : Int32
    keycode_f10           = 291 : Int32
    keycode_f11           = 292 : Int32
    keycode_f12           = 293 : Int32
    keycode_f13           = 294 : Int32
    keycode_f14           = 295 : Int32
    keycode_f15           = 296 : Int32
    keycode_num_lock      = 300 : Int32
    keycode_caps_lock     = 301 : Int32
    keycode_scroll        = 302 : Int32
    keycode_right_shift   = 303 : Int32
    keycode_left_shift    = 304 : Int32
    keycode_right_ctrl    = 305 : Int32
    keycode_left_ctrl     = 306 : Int32
    keycode_right_alt     = 307 : Int32
    keycode_left_alt      = 308 : Int32
    keycode_right_win     = 309 : Int32
    keycode_right_meta    = 309 : Int32
    keycode_right_command = 309 : Int32
    keycode_left_win      = 310 : Int32
    keycode_left_meta     = 310 : Int32
    keycode_left_command  = 310 : Int32
    keycode_sys_request   = 317 : Int32

    keycode_first_printable = keycode_space         : Int32
    keycode_last_printable  = keycode_numpad_equals : Int32

    keycode_to_unicode_lc =
      Char{
        0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15, 
       16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31, 
       32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47, 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',  58,  59,  60,  61,  62,  63, 
       64,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 
      112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,  91,  92,  93,  94,  95, 
       96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 
      112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 
      128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 154, 139, 156, 141, 158, 143, 
      144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 255, 
      160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 
      176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 
      224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 
      240, 241, 242, 243, 244, 245, 246, 215, 248, 249, 250, 251, 252, 253, 254, 223, 
      224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 
      240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,  
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '/', '*', '-', '+',  10,   
      '=',   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   
        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
        0,   0,   0
      } : Char[]

  
    keycode_to_unicode_uc = 
      Char{
        0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15, 
       16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
       32,  33,  34,  35,  36,  37,  38, '"',  40,  41,  42, '=', '<', '_', '>', '?', 
      ')', '!', '@', '#', '$', '%', '^', '&', '*', '(',  58, ':',  60, '+',  62,  63, 
       64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79, 
       80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90, '{', '|', '}',  94,  95, 
      '~',  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79, 
       80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90, 123, 124, 125, 126, 127, 
      128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 
      144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 138, 155, 140, 157, 142, 159, 
      160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 
      176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 
      192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 
      208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 
      192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 
      208, 209, 210, 211, 212, 213, 214, 247, 216, 217, 218, 219, 220, 221, 222, 159, 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '/', '*', '-', '+',  10,   
      '=',   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   
        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
        0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
        0,   0,   0
      } : Char[]

    unicode_to_keycode : Char[]

  METHODS
    method init:
      unicode_to_keycode = ArrayOf<<Char>>[ keycode_to_unicode_lc.count ]
      forEach (i of keycode_to_unicode_uc)
        unicode_to_keycode[ keycode_to_unicode_uc[i] ] = i
        unicode_to_keycode[ keycode_to_unicode_lc[i] ] = i
      endForEach

endClass

#=====================================================================
# MouseEvent
#=====================================================================
compound MouseEvent( Int32 type, Int32 mouse_id, Vector2 position, Int32 button )
  # Contains information about a given mouse event.  The type of event
  # is determined by the method the event is received in -
  # on_mouse_position(), on_mouse_movement(), etc.
  #
  # Parameters:
  #   type
  #     One of: MouseEvent.movement, relative_movement,
  #     button_press, button_release,
  #     wheel_up, wheel_down, 
  #     present, absent
  #
  #   mouse_id
  #     Which mouse is being used.  Normally this will be 1.  For
  #     iPhone, each different simultaneous touch is sent as a
  #     different mouse_id that will remain the same throughout the
  #     duration of the touch.
  #
  #   position
  #     The mouse position at the time of the mouse event.
  #
  #   button
  #     The mouse button that was pressed for appropriate events.

singleton class MouseEventManager
  PROPERTIES
    button_release    = 0 : Int32
    button_press      = 1 : Int32
    relative_movement = 2 : Int32
    movement          = 3 : Int32
    wheel_up          = 4 : Int32
    wheel_down        = 5 : Int32
    present           = 6 : Int32
    absent            = 7 : Int32

  METHODS
    #method to_String( MouseEvent e ).String:
      #return "#$ ($,$) button:$" (e.mouse_id,e.x,e.y,e.z)
endClass


#=====================================================================
# AccelerationEvent
# RollPitchYaw
#=====================================================================
compound AccelerationEvent( Int32 controller_id, Real64 x, Real64 y, Real64 z )

singleton class AccelerationEventManager
  METHODS
    method orientation( AccelerationEvent e ).RollPitchYaw:
      local var x = e.x
      local var y = e.y
      local var z = e.z
      return RollPitchYaw( Vector2(x,z).radians, Vector2(y,z).radians, Vector2(x,y).radians )

    method to_String( AccelerationEvent e ).String:
      return "#$ ($,$,$)" (e.controller_id,e.x,e.y,e.z)
endClass

compound RollPitchYaw( Radians roll, Radians pitch, Radians yaw )

singleton class RollPitchYawManager
  METHODS
    method to_String( RollPitchYaw orientation ).String:
      return "($,$,$)" (Degrees(orientation.roll),
          Degrees(orientation.pitch),Degrees(orientation.yaw))
endClass


#=====================================================================
# SystemEvent
#=====================================================================
compound SystemEvent( Int32 type )

singleton class SystemEventManager
  PROPERTIES
    garbage_collected = 1 : Int32
      # A garbage collection just happened.

    resources_loaded   = 2 : Int32
      # All ImageLoader (etc.) resources are ready.

  METHODS
    method to_String( SystemEvent e ).String:
      which (e.type)
        case garbage_collected: return "gc"
        case resources_loaded:  return "res loaded"
        others: return "???"
      endWhich
endClass


#=====================================================================
# JoystickEvent
#=====================================================================
singleton class Joystick
  PROPERTIES
    hat_centered = 0 : Int32
    hat_up       = 1 : Int32
    hat_right    = 2 : Int32
    hat_down     = 4 : Int32
    hat_left     = 8 : Int32

    hat_up_left  = (hat_up | hat_left)  : Int32
    hat_up_right = (hat_up | hat_right) : Int32
    hat_down_left  = (hat_down | hat_left)  : Int32
    hat_down_right = (hat_down | hat_right) : Int32
endClass

compound JoystickEvent( Int32 type, Int32 joystick_id, Int32 index, Real64 delta )
  # Contains information about a given joystick event.
  #
  # Parameters:
  #   type
  #     One of:
  #       JoystickEvent.button_release
  #       JoystickEvent.button_press
  #       JoystickEvent.movement
  #       JoystickEvent.hat_movement
  #
  #   joystick_id
  #     The joystick index of which joystick caused the event (1-4).
  #
  #   index
  #     The one-based index of which axis, button, or hat was used.
  #     For axis events, the X axis is index 1 and the Y axis is index 2.
  #
  #   delta [-1.0..1.0]
  #     on_joystick_movement()     
  #       Relative motion on axis #index.

singleton class JoystickEventManager
  PROPERTIES
    button_release = 0 : Int32
    button_press   = 1 : Int32
    movement       = 2 : Int32
    hat_movement   = 3 : Int32
    connected      = 4 : Int32
    disconnected   = 5 : Int32
endClass


#=====================================================================
# Input management
#=====================================================================
singleton class NativeEvent
  # Internal use - defines the constants used to pass event messages
  # from the native layer to the application layer.
  PROPERTIES
    update                  =   1 : Int32
    draw                    =   2 : Int32
    idle                    =   3 : Int32
    key_press               =   4 : Int32
    key_release             =   5 : Int32
    mouse_move_relative     =   6 : Int32
    mouse_move_absolute     =   7 : Int32
    mouse_button_press      =   8 : Int32
    mouse_button_release    =   9 : Int32
    mouse_wheel             =  10 : Int32
    mouse_presence          =  11 : Int32
    joystick_axis           =  12 : Int32
    joystick_button_press   =  13 : Int32
    joystick_button_release =  14 : Int32
    joystick_hat            =  15 : Int32
    joystick_connected      =  16 : Int32
endClass


requisite singleton class Input : InputDispatcher
  # Manages application input.
  PROPERTIES
    first_repeat_delay_in_ticks = 30 : Int32
      # Internal use.

    next_repeat_delay_in_ticks  =  3 : Int32

    key_modifiers : Int32
      # The set of flags representing which SHIFT, ALT, and CTRL key 
      # modifiers are currently pressed.  Most applications will want
      # to call one of these methods instead:
      #
      #   shift_pressed()
      #   ctrl_pressed()
      #   alt_pressed()
      #   caps_locked()

    key_state = ArrayOf<<Logical>>[512]  : Logical[]
      # "true" if the given raw keycode (e.g. Key.keycode_a) is
      # currently pressed, "false" if not.

    last_key_pressed          : Int32
      # Internal use - used for key repeating.

    key_repeat_delay_in_ticks : Int32
      # Internal use - a countdown until a pressed key repeats.

    mouse_present=true  : Logical
      # "true" if this application has the mouse focus.

    mouse_button_state=ArrayOf<<Logical>>[11] : Logical[]
      # mouse_button_state[i] (where i is 1 to 10) is "true" if
      # that mouse button is currently pressed.

    joystick_connected = ArrayOf<<Logical>>[5] : Logical[]
      # True if a given joystick 1..4 is detected and able to provide input.

    is_iphone : Logical

  METHODS
    method init:
      is_iphone = (System.os == "iphone")

    method shift_pressed.Logical:
      # Returns "true" if either of the shift keys is currently pressed.
      return (key_modifiers & Key.modifier_shift) != 0

    method shift_pressed( Logical setting ):
      # Internal use - shift_pressed property-set.
      if (setting) key_modifiers |=  Key.modifier_shift
      else         key_modifiers &= !Key.modifier_shift

    method caps_locked.Logical:
      # Returns "true" if CAPS LOCK is on.
      return (key_modifiers & Key.modifier_caps_lock) != 0

    method caps_locked( Logical setting ):
      # Internal use - caps_locked property-set.
      if (setting) key_modifiers |=  Key.modifier_caps_lock
      else         key_modifiers &= !Key.modifier_caps_lock

    method ctrl_pressed.Logical:
      # Returns "true" if either of the control keys is currently
      # pressed.
      return (key_modifiers & Key.modifier_ctrl) != 0

    method ctrl_pressed( Logical setting ):
      # Internal use - ctrl_pressed property-set.
      if (setting) key_modifiers |=  Key.modifier_ctrl
      else         key_modifiers &= !Key.modifier_ctrl

    method alt_pressed.Logical:
      # Returns "true" if either of the alt keys is currently
      # pressed.
      return (key_modifiers & Key.modifier_alt) != 0

    method alt_pressed( Logical setting ):
      # Internal use - alt_pressed property-set.
      if (setting) key_modifiers |=  Key.modifier_alt
      else         key_modifiers &= !Key.modifier_alt

    method update:
      if (is_iphone)
        dispatch( AccelerationEvent(1,IPhone.x_acceleration,IPhone.y_acceleration,IPhone.z_acceleration) )
      endIf

      # Internal use - updates the input system.
      if (last_key_pressed > 0)
        key_repeat_delay_in_ticks--
        if (key_repeat_delay_in_ticks <= 0)
          dispatch( KeyEvent(repeat, last_key_pressed, keycode_to_Char(last_key_pressed), key_modifiers) )
          key_repeat_delay_in_ticks = next_repeat_delay_in_ticks
        endIf
      endIf

    method keycode_to_Char( Int32 keycode ).Char:
      # Converts the given keycode into its Unicode equivalent, taking
      # the current shift keys into consideration.

      # test special cases in the midst of the printable char range
      if (keycode == Key.keycode_delete) return Char(0)
      if (keycode == Key.keycode_numpad_enter) return Char(0)

      if (keycode >= Key.keycode_first_printable and keycode <= Key.keycode_last_printable)
        if (shift_pressed ~ caps_locked) 
          return Key.keycode_to_unicode_uc[ keycode ]
        else
          return Key.keycode_to_unicode_lc[ keycode ]
        endIf
      endIf

      return Char(0)

    requisite method handle_event( Int32 type, Int32 id, Int32 i, Real64 x, Real64 y ):
      # Internal use - called by the native layer to relay input 
      # events.
      try
        which (type)
          case NativeEvent.update:
            ResourceManager.update
            GUIManager.update

          case NativeEvent.draw:
            GUIManager.draw

          case NativeEvent.idle:
            sleep(i)

          case NativeEvent.key_press:
            local Int32 code
            local Char ch
            if (id?)
              ch = i
              code = Key.unicode_to_keycode[ch % Key.unicode_to_keycode.count]
            else
              code = i
              ch = keycode_to_Char( code )
            endIf
            key_state[code]  = true
            last_key_pressed = code
            key_repeat_delay_in_ticks = first_repeat_delay_in_ticks

            if (ch == 0) 
              which (code)
                case Key.keycode_left_shift:  shift_pressed = true
                case Key.keycode_right_shift: shift_pressed = true
                case Key.keycode_left_ctrl:   ctrl_pressed  = true
                case Key.keycode_right_ctrl:  ctrl_pressed  = true
                case Key.keycode_left_alt:    alt_pressed   = true
                case Key.keycode_right_alt:   alt_pressed   = true
                case Key.keycode_caps_lock:   caps_locked   = true
              endWhich
            endIf

            if (code == Key.keycode_enter and alt_pressed)
              # ALT+ENTER toggles fullscreen
              key_state[code]  = false
              last_key_pressed = 0
              Application.on_toggle_fullscreen
            elseIf (code == Key.keycode_f4 and alt_pressed)
              # ALT+F4 exits app
              key_state[code]  = false
              last_key_pressed = 0
              Application.on_exit_request
            else
              dispatch( KeyEvent(press, code, ch, key_modifiers) )
              dispatch( KeyEvent(repeat, code, ch, key_modifiers) )
            endIf

          case NativeEvent.key_release:
            local Int32 code
            local Char ch
            if (id?)
              ch = i
              code = Key.unicode_to_keycode[ch % Key.unicode_to_keycode.count]
            else
              code = i
              ch = keycode_to_Char( code )
            endIf
            key_state[code] = false
            if (code == last_key_pressed) last_key_pressed = 0
            if (ch > 0) 
              #trace( "Key pressed:  $" (ch) )
            else
              which (code)
                case Key.keycode_left_shift:  shift_pressed = false
                case Key.keycode_right_shift: shift_pressed = false
                case Key.keycode_left_ctrl:   ctrl_pressed  = false
                case Key.keycode_right_ctrl:  ctrl_pressed  = false
                case Key.keycode_left_alt:    alt_pressed   = false
                case Key.keycode_right_alt:   alt_pressed   = false
                case Key.keycode_caps_lock:   caps_locked   = false
              endWhich
            endIf
            if (code == Key.keycode_enter and alt_pressed)
              # ALT+ENTER finishing
            elseIf (code == Key.keycode_f4 and alt_pressed)
              # ALT+F4 finishing
            else
              dispatch( KeyEvent(release, code, ch, key_modifiers) )
            endIf

          #case NativeEvent.mouse_move_relative:

          case NativeEvent.mouse_move_absolute:
            local var pos = Vector2(x,y)
            dispatch( MouseEvent(movement,id,pos,0) )

          case NativeEvent.mouse_button_press:
            mouse_button_state[i] = true
            dispatch( MouseEvent(button_press,id,Vector2(x,y),i) )

          case NativeEvent.mouse_button_release:
            mouse_button_state[i] = false
            dispatch( MouseEvent(button_release,id,Vector2(x,y),i) )

          #case NativeEvent.mouse_wheel:
          #case NativeEvent.mouse_presence:
#{
          case NativeEvent.joystick_axis:

            forEach (view in views)
              view.on( JoystickEvent(movement,id,i,x) )
            endForEach

          case NativeEvent.trackball_axis:
            local Int32 a = i
            local Int32 joystick = a.right_shifted(8)
            local Int32 index = a & 255
            local Int32 b = y
            dispatch_trackball_movement( JoystickEvent(joystick,index,x,y) )

          case NativeEvent.joystick_button_press:
            dispatch_joystick_button_press( JoystickEvent(i,x,0,0) )

          case NativeEvent.joystick_button_release:
            dispatch_joystick_button_release( JoystickEvent(i,x,0,0) )

          case NativeEvent.joystick_hat:
            local Int32 a = i
            local Int32 joystick = a.right_shifted(8)
            local Int32 index = a & 255
            dispatch_joystick_hat_movement( JoystickEvent(joystick,index,x,0) )

          case NativeEvent.joystick_connected:
            local Int32 joystick = i
            local Int32 status = x
            if (status == 1.0) joystick_connected[joystick] = true
            else               joystick_connected[joystick] = false
            dispatch_joystick_connected( JoystickEvent(joystick,0,status,0) )
}#
        endWhich

      catch (Error err)
        trace( err.to_String )
      endTry
endClass

#=====================================================================
# Color, RealColor, HSV
#=====================================================================
compound Color( Int32 argb )
  # Defines a 32-bit color 0xAARRGGBB.

singleton class ColorManager
  # Contains Color constands and methods for operating on Color compounds.
  PROPERTIES
    red(255,0,0)       : Color
    orange(255,128,0)  : Color
    yellow(255,255,0)  : Color
    green(0,255,0)     : Color
    cyan(0,255,255)    : Color
    blue(0,0,255)      : Color
    magenta(255,0,255) : Color
    white(255,255,255) : Color
    black(0,0,0)       : Color
    gray(128,128,128)  : Color
    light_gray(192,192,192) : Color
    dark_gray(64,64,64)     : Color

  METHODS
    method create_from( Int32 r, Int32 g, Int32 b, Int32 a=255 ).Color:
      # Creates a Color compound from the given integer 
      # components.
      #
      # Parameters:
      #   r - The red component 0-255.
      #   g - The green component 0-255.
      #   b - The blue component 0-255.
      #   a - The alpha component 0-255.  0 is completely 
      #       transparent, 255 [default] is completely opaque.
      return Color(a.left_shifted(24)|r.left_shifted(16)|g.left_shifted(8)|b)

    method create_from( RealColor real_color ).Color:
      # Creates a Color compound from the given RealColor 
      # compound.
      return Color( real_color.red*255, real_color.green*255, real_color.blue*255, 
          real_color.alpha*255 )

    method create_from( HSV hsv ).Color:
      # Creates a Color compound from the given HSV compound.
      local Real64 h = hsv.hue
      local Real64 s = hsv.saturation
      local Real64 v = hsv.value
      local Real64 r, g, b
    
      h %= 1.0

      if (s > 1) s = 1
      elseIf (s < 0) s = 0
      if (v > 1) v = 1
      elseIf (v < 0) v = 0
      
      if (v == 0) return Color(0,0,0) # Black!
      if (s == 0) return Color(RealColor(v,v,v))
      
      local Real64 h5 = h * 5
      local Int32  i = Int32(h5)
      local Real64 f = h5 - i
      
      local Real64 p = v * (1 - s)
      local Real64 q = v * (1 - s * f)
      local Real64 t = v * (1 - s * (1 - f))
      
      which (i)
        case 0: return Color( RealColor(v, t, p) )
        case 1: return Color( RealColor(q, v, p) )
        case 2: return Color( RealColor(p, v, t) )
        case 3: return Color( RealColor(p, q, v) )
        case 4: return Color( RealColor(t, p, v) )
        #case 5 is below...
      endWhich
      
      return Color(RealColor(v, p, q))

    method create_from( Color top_color, Color bottom_color ).Color:
      # Creates a Color compound by alpha-blending the two given 
      # Colors.  For each RGB color component, the difference to get 
      # from the bottom color to the top color is first multiplied by 
      # the top color's alpha value as a proportion.  The alpha
      # value of the new color is 255.
      local Int32 tr = top_color.red
      local Int32 tg = top_color.green
      local Int32 tb = top_color.blue

      local Int32 r = bottom_color.red
      local Int32 g = bottom_color.green
      local Int32 b = bottom_color.blue

      local Real64 alpha = top_color.alpha / 255.0

      b += ((tb - b) * alpha).(Int32)
      g += ((tg - g) * alpha).(Int32)
      r += ((tr - r) * alpha).(Int32)

      return Color( r, g, b, 255 )

    method alpha( Color color ).Int32:
      return (color.argb.right_shifted(24) & 0xff)

    method red( Color color ).Int32:
      return (color.argb.right_shifted(16) & 0xff)

    method green( Color color ).Int32:
      return (color.argb.right_shifted(8) & 0xff)

    method blue( Color color ).Int32:
      return (color.argb & 0xff)

    method to_String( Color color ).String:
      return color.argb.to_String(16)

    method op*( Color c, Real64 factor ).Color:
      # Multiplies the color components of 'c' by the given scaling factor
      # while preserving Alpha.
      return Color(
          Int32(c.red*factor).clamped(0,255),
          Int32(c.green*factor).clamped(0,255),
          Int32(c.blue*factor).clamped(0,255),
          c.alpha
        )

    method op/( Color c, Real64 factor ).Color:
      # Divides the color components of 'c' by the given scaling factor
      # while preserving Alpha.
      return c * (1.0 / factor)

    method op&( Color c, Int32 mask ).Color:
      # Performs a bitwise AND of 'c' and 'mask'.  For example to set
      # the alpha value of a color to zero:
      #
      #   c = c & 0x00ffffff   
      return Color( c.argb & mask )

    method op|( Color c, Int32 mask ).Color:
      # Performs a bitwise OR of 'c' and 'mask'.  For example to set
      # the alpha value of a color to 255:
      #
      #   c = c | 0xff000000   
      return Color( c.argb | mask )

    method op!( Color c ).Color:
      # Performs a bitwise complement of color 'c'.
      return Color( !c.argb )

endClass


compound RealColor( Real64 red, Real64 green, Real64 blue, Real64 alpha )
  # Defines a color using real number red, green, blue, and alpha
  # color components, each 0..1.0.

singleton class RealColorManager
  # Contains methods for operating on RealColor compounds.
  METHODS
    method create_from( Real64 r, Real64 g, Real64 b ).RealColor:
      # Creates a RealColor compound from the given real number
      # components.  The alpha value is set to be 1.0.
      #
      # Parameters:
      #   r - The red component 0.0-1.0.
      #   g - The green component 0.0-1.0.
      #   b - The blue component 0.0-1.0.
      return RealColor( r, g, b, 1.0 )

    method create_from( Color c ).RealColor:
      # Creates a RealColor compound from the given Color compound.
      return RealColor( 
          c.blue  / 255.0,
          c.green / 255.0,
          c.red   / 255.0,
          c.alpha / 255.0
        )

    method create_from( HSV hsv ).RealColor:
      # Creates a RealColor compound from the given real number 
      # components.
      #
      # Parameters:
      #   r - The red component 0-1.0.
      #   g - The green component 0-1.0.
      #   b - The blue component 0-1.0.
      #   a - The alpha component 0-1.0.  0 is completely 
      #       transparent, 1.0 [default] is completely opaque.
      return RealColor(Color(hsv))

    method to_String( RealColor color ).String:
      # Returns an RGBA string representation of 'color'.
      return "($,$,$,$)" (color.red, color.green, color.blue, color.alpha)

    method op*( RealColor c, Real64 factor ).RealColor:
      # Multiplies the color components of 'c' by the given scaling factor
      # while preserving Alpha.
      return RealColor(
          (c.red*factor).clamped(0,1.0),
          (c.green*factor).clamped(0,1.0),
          (c.blue*factor).clamped(0,1.0),
          c.alpha
        )

    method op/( RealColor c, Real64 factor ).RealColor:
      # Divides the color components of 'c' by the given scaling factor
      # while preserving Alpha.
      return c * (1.0 / factor)

endClass


compound HSV( Real64 hue, Real64 saturation, Real64 value )
  # Defines a color using real number hue, saturation, and value
  # color components, each 0..1.0.

singleton class HSVManager
  # Contains methods for operating on HSV compounds.
  METHODS
    method create_from( Color color ).HSV:
      # Creates a HSV compound from the given Color compound.
      return HSV( RealColor(color) )

    method create_from( RealColor argb ).HSV:
      # Creates a HSV compound from the given RealColor compound.
      local Real64 r = argb.red.clamped(0.0,1.0)
      local Real64 g = argb.green.clamped(0.0,1.0)
      local Real64 b = argb.blue.clamped(0.0,1.0)
      
      local Real64 maxrgb = max( max(r, g), b)
      local Real64 minrgb = min( min(r, g), b)
      
      local Real64 hue, saturation
      local Real64 value = maxrgb
      
      if (maxrgb != 0) saturation = (maxrgb - minrgb) / minrgb  # SATURATION

      if (value != 0)
        # HUE (not valid if saturation == 0)
        local Real64 rc = (maxrgb - r) / (maxrgb - minrgb)
        local Real64 gc = (maxrgb - g) / (maxrgb - minrgb)
        local Real64 bc = (maxrgb - b) / (maxrgb - minrgb)
        
        if (r == maxrgb)     hue = (bc - gc) / 6.0
        elseIf (g == maxrgb) hue = (rc - bc) / 6.0 + 2.0 / 6.0
        else                 hue = (gc - rc) / 6.0 + 4.0 / 6.0
        
        if (value < 0) hue += 1
      endIf
    
      return HSV( hue, saturation, value )

    method to_String( HSV color ).String:
      # Returns an HSV string representation of 'color'.
      return "($,$,$)" (color.hue, color.saturation, color.value)

    method op*( HSV c, Real64 factor ).HSV:
      # Multiplies the color components of 'c' by the given scaling factor
      # while preserving Alpha.
      return HSV( RealColor(c) * factor )

    method op/( HSV c, Real64 factor ).HSV:
      # Divides the color components of 'c' by the given scaling factor
      # while preserving Alpha.
      return c * (1.0 / factor)
endClass


augment RandomNumberGenerator
  METHODS
    method random_Vector2.Vector2:
      # Creates a Vector2 compound with randomized (x,y) values,
      # each in the range (0.0,1.0) exclusive.
      #
      # Example:
      #   local var random_screen_pos = random_Vector2 * display_size
      return Vector2( random_Real64, random_Real64 )

    method random_Color.Color:
      # Returns a color with randomized (r,g,b) values and an
      # alpha of 255.
      return Color(random_RealColor)
  
    method random_RealColor.RealColor:
      # Returns a color with randomized (r,g,b) values and an
      # alpha of 1.0.
      return RealColor(random_Real64,random_Real64,random_Real64)

    method random_HSV.HSV:
      # Returns an HSV color with randomized (h,s,v) values.
      return HSV(random_RealColor)
endAugment

compound Blend( Int32 src_blend, Int32 dest_blend )

singleton class BlendManager
  PROPERTIES
    # src and dest blending modes
    zero               =  0 : Int32
    one                =  1 : Int32
    src_alpha          =  2 : Int32
    inverse_src_alpha  =  3 : Int32
    dest_alpha         =  4 : Int32
    inverse_dest_alpha =  5 : Int32

    # src only
    dest_color         =  6 : Int32
    inverse_dest_color =  7 : Int32
    opaque             =  8 : Int32

    # dest only
    src_color          =  9 : Int32
    inverse_src_color  = 10 : Int32

    # predefined (src,dest) blending modes
    normal( src_alpha, inverse_src_alpha ) : Blend
      # Standard modulation

    overexpose( src_alpha, one ) : Blend
      # Specifies that an image should be drawn in "overexpose" mode,
      # where color values are added to the destination rather
      # than being blended with it.

    additive( src_alpha, one ) : Blend
      # Same as 'overexpose'.

endClass


compound Render( Int32 flags )

singleton class RenderManager
  # Render constants that can be passed to many of the drawing 
  # methods and stored with Images as "render_flags".
  PROPERTIES
    default = Render(0) : Render
      # Default render flags

    point_filter = Render(0b00000001) : Render
      # Specifies that an image should be drawn using point filtering
      # (no smoothing).  An image without the point_filter flag will
      # be drawn with linear filtering (smoothing).  
      #
      # Images have 'point_filter' and 'linear_filter' convenience 
      # methods that access this flag.

    fixed_color = Render(0b00000100) : Render
      # Specifies that an image should be drawn with its normal alpha
      # but using a constant color (specified by the image's 'color'
      # property).  Good for silhouette effects.
      #
      # Images have 'fixed_color' convenience methods that access this flag.

    texture_wrap = Render(0b00001000) : Render
      # When an image's UV texture coordinates are adjusted to be
      # larger than actual texture, this flag causes the texture
      # to wrap.  For example, setting the UV coordinates to (0,0),
      # (3,2) would cause an image to tile 3 times horizontally and
      # 2 times vertically within its normal image area when it's
      # drawn.  The absence of texture_wrap indicates texture clamp
      # (the image default).
      #
      # Images have 'texture_wrap' convenience methods that access this flag.

  METHODS
    method op|( Render r1, Render r2 ).Render:
      return Render( r1.flags | r2.flags )

    method op|( Render r1, Int32 flags ).Render:
      return Render( r1.flags | flags )

    method op|( Int32 flags, Render r2 ).Render:
      return Render( flags | r2.flags )

    method op+( Render r1, Render r2 ).Render:
      return Render( r1.flags + r2.flags )

    method op+( Render r1, Int32 flags ).Render:
      return Render( r1.flags + flags )

    method op+( Int32 flags, Render r2 ).Render:
      return Render( flags + r2.flags )

    method op&( Render r1, Render r2 ).Render:
      return Render( r1.flags & r2.flags )

    method op&( Render r1, Int32 flags ).Render:
      return Render( r1.flags & flags )

    method op&( Int32 flags, Render r2 ).Render:
      return Render( flags & r2.flags )

    method op!( Render r ).Render:
      return Render( !r.flags )

endClass


#=====================================================================
# Vector2
#=====================================================================
compound Vector2( Real64 x, Real64 y )
  # Represents a 2D Coordinate that can be interacted with using 
  # polar or rectangular coordinates. This datatype is also useful 
  # for representing 2D vectors and includes supporting functionality
  # such as dot and cross operations.
  #
  # Example:
  #   local Vector2 v(3,4)

singleton class Vector2Manager
  # Contains methods for operating on Vector2 compounds.
  PROPERTIES
    zero(0,0) : Vector2
    invalid(NaN,NaN) : Vector2
    sqrt_0_5 = sqrt(0.5) : Real64

  METHODS
    method create_from( Real64 _magnitude, Radians angle ).Vector2:
      # Creates a Vector2 compound from the given magnitude and
      # angle in radians.
      #
      # Example:
      #   local Vector2 v( 5, pi/2 )
      return Vector2( _magnitude * cos(angle), _magnitude * sin(angle) )

    method create_from( Real64 _magnitude, Degrees angle ).Vector2:
      # Creates a Vector2 compound from the given _magnitude and
      # angle in degrees.
      #
      # Example:
      #   local Vector2 v( 5, Degrees(90) )
      return create_from( _magnitude, to_Radians(angle) )

    method to_String( Vector2 v ).String:
      # Returns a string representation of 'v'.
      return "($(.2),$(.2))" (v.x,v.y)

    method area( Vector2 v ).Real64:
      # Returns x*y.
      return v.x * v.y

    method max( Vector2 v1, Vector2 v2 ).Vector2:
      # Returns a vector containing the largest x and the largest y
      # between the two vectors.
      #
      # Example:
      #   println( max(Vector2(3,6), Vector2(4,5)) )
      #   # prints: (4.0,6.0)
      return Vector2( max(v1.x,v2.x), max(v1.y,v2.y) )

    method max( Vector2 v ).Real64:
      # Returns the largest of the two vector components.
      #
      # Example:
      #   println( Vector2(3,4).max )  # prints: 4.00
      return max( v.x, v.y )

    method min( Vector2 v1, Vector2 v2 ).Vector2:
      # Returns a vector containing the smallest x and the smallest y
      # between the two vectors.
      #
      # Example:
      #   println( min(Vector2(3,6), Vector2(4,5)) )
      #   # prints: (3.0,5.0)
      return Vector2( min(v1.x,v2.x), min(v1.y,v2.y) )

    method min( Vector2 v ).Real64:
      # Returns the smallest of the two vector components.
      #
      # Example:
      #   println( Vector2(3,4).min )  # prints: 3.00
      return min( v.x, v.y )

    method bounding_box( Vector2 v ).Box:
      # Returns a bounding box that encloses 'v'.  This will be a 1x1 Box
      # at position 'v'.
      #
      # Example:
      #   bounding_box = pt.bounding_box
      return Box( v, Vector2(1,1) )

    method bounding_circle( Vector2 v ).Circle:
      # Returns a bounding circle that encloses 'v'.  The circle will be
      # at position v and have radius sqrt(0.5).
      #
      # Example:
      #   bounding_circle = pt.bounding_circle
      return Circle( v, sqrt_0_5 )

    method abs( Vector2 v ).Vector2:
      # Returns the vector containing the absolute value of each
      # component of 'v'.
      #
      # Examples:
      #   println( v.abs )
      #   println( abs(v) )
      return Vector2( abs(v.x), abs(v.y) )

    method floor( Vector2 v ).Vector2:
      # Returns the vector containing the floor of each
      # component of 'v'.
      #
      # Examples:
      #   println( v.floor )
      #   println( floor(v) )
      return Vector2( floor(v.x), floor(v.y) )

    method round( Vector2 v ).Vector2:
      # Returns the vector containing the rounded-off values of each
      # component of 'v'.
      #
      # Examples:
      #   println( v.round )
      #   println( round(v) )
      return floor( v + 0.5 )

    method ceiling( Vector2 v ).Vector2:
      # Returns the vector containing the ceiling of each
      # component of 'v'.
      #
      # Examples:
      #   println( v.ceiling )
      #   println( ceiling(v) )
      return Vector2( ceiling(v.x), ceiling(v.y) )

    method distance_to( Vector2 v1, Vector2 v2 ).Real64:
      # Returns the straight-line distance between v1 and v2.
      #
      # Example:
      #   println( v1.distance_to(v2) )
      return (v2 - v1).magnitude

    method swapped( Vector2 v ).Vector2:
      # Returns a Vector2 with the components swapped; if v=Vector2(x,y)
      # then v.swapped == Vector2(y,x).
      return Vector2(v.y,v.x)

    method transformed( Vector2 v, Transform xform ).Vector2: native
      # Applies the given transformation to the given vector.
      #
      # Example:
      #   v = v.transformed( Transform().rotated(pi/2) )

    method rotated( Vector2 v, Radians rad ).Vector2:
      # Rotates 'v' around the origin by the given number of radians.
      #
      # Example:
      #   v2 = v1.rotated( pi/2 )
      return Vector2( v.magnitude, v.radians + rad )

    method rotated( Vector2 v, Degrees deg ).Vector2:
      # Rotates 'v' around the origin by the given number of degrees.
      #
      # Example:
      #   v2 = v1.rotated( Degrees(90) )
      return Vector2( v.magnitude, v.degrees + deg )

    method normalized( Vector2 v ).Vector2:
      # Normalizes 'v' to have the same angle with magnitude 1.0.
      #
      # Example:
      #   v = v.normalized
      return Vector2( 1.0, v.radians )

    method dot( Vector2 v1, Vector2 v2 ).Real64:
      # Returns the dot product of 'v1' and 'v2'.  Returns
      #   v1.x*v2.x + v1.y*v2.y
      #
      # Example:
      #   dot_product = v1.dot(v2)
      return v1.x * v2.x + v1.y * v2.y

    method cross( Vector2 v1, Vector2 v2 ).Real64:
      # Returns the cross product of 'v1' and 'v2':
      #   v1.x*v2.y - v1.y*v2.x
      #
      # Example:
      #   cross_product = v1.cross(v2)
      return v1.x * v2.y - v1.y * v2.x

    method parallelum( Vector2 v, Vector2 axis ).Vector2:
      # Returns the component of 'v' that lies along the axis defined
      # by the second parameter.
      #
      # Example:
      #   x = v.parallelum(axis)
      return (v.dot(axis) / axis.dot(axis)) * axis

    method perpendiculum( Vector2 v, Vector2 axis ).Vector2:
      # Returns the component of 'v' that lies perpendicular to the axis defined
      # by the second parameter.
      #
      # Example:
      #   y = v.perpendiculum(axis)
      return v - v.parallelum(axis)

    method parallelum( Vector2 v, Line line ).Vector2:
      # Returns the component of 'v' that lies along the axis defined
      # by the second parameter.
      #
      # Example:
      #   x = v.parallelum(axis)
      local var axis = line.pt2 - line.pt1
      return (v.dot(axis) / axis.dot(axis)) * axis

    method perpendiculum( Vector2 v, Line line ).Vector2:
      # Returns the component of 'v' that lies perpendicular to the axis defined
      # by the second parameter.
      #
      # Example:
      #   y = v.perpendiculum(axis)
      local var axis = line.pt2 - line.pt1
      return v - v.parallelum(axis)

    method projection_on( Vector2 v, Line line ).Vector2:
      # Returns the projection of 'v' on 'line'.  The return value
      # is a point along the axis of 'line' although it may be outside
      # the beginning or end point of the line.
      #
      # Example:
      #   y = v.projection_on(axis)
      local var P1 = line.pt1
      local var A = v - P1
      local var B = line.pt2 - P1
      return P1 + (A.dot(B) / B.dot(B)) * B

    method clamped( Vector2 v, Box b ).Vector2:
      # Adjusts 'v' to be within the boundaries of the given box.
      #
      # Example:
      #   cursor = cursor.clamped( display_region )
      local var vx = v.x
      local var vy = v.y
      local var x1 = b.x1
      local var y1 = b.y1
      local var x2 = b.x2
      local var y2 = b.y2

      if (vx < x1) vx = x1
      elseIf (vx > x2) vx = x2

      if (vy < y1) vy = y1
      elseIf (vy > y2) vy = y2

      return Vector2(vx,vy)

    method clamped( Vector2 v, Corners c ).Vector2:
      # Adjusts 'v' to be within the given corners.
      #
      # Example:
      #   cursor = cursor.clamped( Corners(-1,-1,1,1) )
      local var vx = v.x
      local var vy = v.y
      local var x1 = c.x1
      local var y1 = c.y1
      local var x2 = c.x2
      local var y2 = c.y2

      if (vx < x1) vx = x1
      elseIf (vx > x2) vx = x2

      if (vy < y1) vy = y1
      elseIf (vy > y2) vy = y2

      return Vector2(vx,vy)

    method clamped( Vector2 v, Real64 x1, Real64 y1, Real64 x2, Real64 y2 ).Vector2:
      # Adjusts 'v' to be within the given corners.
      #
      # Example:
      #   cursor = cursor.clamped(-1,-1,1,1)
      local var vx = v.x
      local var vy = v.y

      if (vx < x1) vx = x1
      elseIf (vx > x2) vx = x2

      if (vy < y1) vy = y1
      elseIf (vy > y2) vy = y2

      return Vector2(vx,vy)

    method clamped( Vector2 v, Line line ).Vector2:
      # Returns the point along the given line segment that is closest
      # to 'v'.
      #
      # Example:
      #
      #   closest_pt_on_line = v.clamped(line)
      #
      # Notes:
      #
      # Points along the line are defined by:
      #
      #   Line(t) = line.pt1 + t * (line.pt2 - line.pt1)
      #
      # where t is 0 to 1.  We can define t as:
      #
      #   A = v - line.pt1
      #   B = line.pt2 - line.pt1
      #   t = dot(A,B) / dot(B,B)
      #
      # as this is the projection of A along and proportional to B.
      local var P1 = line.pt1
      local var P2 = line.pt2
      local var A = v - P1
      local var B = P2 - P1
      local var t_numer = A.dot(B)
      if (t_numer < 0) return P1
      local var t_denom = B.dot(B)
      if (t_numer > t_denom) return P2
      return P1 + (t_numer / t_denom) * B

    method normal( Vector2 v ).Vector2:
      # Returns the normal of the given vector.
      #
      # Example:
      #   println( v.normal )
      return Vector2( -v.y, v.x )
      
    method radians( Vector2 v ).Radians:
      # Returns the angle of the given vector in radians.
      #
      # Example:
      #   println( v.radians )
      return atan2(v.y,v.x)

    method degrees( Vector2 v ).Degrees:
      # Returns the angle of the given vector in degrees.
      #
      # Example:
      #   println( v.degrees )
      return Degrees(atan2(v.y,v.x))

    method magnitude( Vector2 v ).Real64:
      # Returns the magnitude (radial length) of the given vector.
      #
      # Example:
      #   println( v.magnitude )
      return sqrt( v.x^2 + v.y^2 )

    method op+( Vector2 v1, Vector2 v2 ).Vector2:
      # Returns the vector sum v3 = v1 + v2 where
      #   v3.x = v1.x + v2.x
      #   v3.y = v1.y + v2.y
      #
      # Examples:
      #   v3 = v1 + v2
      #   v1 += v2
      return Vector2( v1.x + v2.x, v1.y + v2.y )

    method op-( Vector2 v1, Vector2 v2 ).Vector2:
      # Returns the vector sum v3 = v1 - v2 where
      #   v3.x = v1.x - v2.x
      #   v3.y = v1.y - v2.y
      #
      # Examples:
      #   v3 = v1 - v2
      #   v1 -= v2
      return Vector2( v1.x - v2.x, v1.y - v2.y )

    method op*( Vector2 v1, Vector2 v2 ).Vector2:
      # Returns the vector product v3 = v1 * v2 where
      #   v3.x = v1.x * v2.x
      #   v3.y = v1.y * v2.y
      #
      # Examples:
      #   v3 = v1 * v2
      #   v1 *= v2
      return Vector2( v1.x * v2.x, v1.y * v2.y )

    method op/( Vector2 v1, Vector2 v2 ).Vector2:
      # Returns the vector product v3 = v1 / v2 where
      #   v3.x = v1.x / v2.x
      #   v3.y = v1.y / v2.y
      #
      # Examples:
      #   v3 = v1 / v2
      #   v1 /= v2
      return Vector2( v1.x / v2.x, v1.y / v2.y )

    method op%( Vector2 v1, Vector2 v2 ).Vector2:
      # Returns the vector product v3 = v1 % v2 where
      #   v3.x = v1.x % v2.x
      #   v3.y = v1.y % v2.y
      #
      # Examples:
      #   v3 = v1 % v2
      #   v1 %= v2
      return Vector2( v1.x % v2.x, v1.y % v2.y )

    method op-( Vector2 v ).Vector2:
      # Returns the negative of this vector v2 = -v1 where
      #   v2.x = -v1.x
      #   v2.y = -v1.y
      #
      # Example:
      #   v1 = -v1
      return Vector2( -v.x, -v.y )

    method op+( Vector2 v1, Real64 n ).Vector2:
      # Adds 'n' to both components of v1.  Equivalent to
      #   v1 + Vector2(n,n)
      #
      # Examples:
      #   v = v + 5
      #   v += 5
      return Vector2( v1.x + n, v1.y + n )

    method op-( Vector2 v1, Real64 n ).Vector2:
      # Subtracts 'n' from both components of v1.  Equivalent to
      #   v1 - Vector2(n,n)
      #
      # Examples:
      #   v = v - 5
      #   v -= 5
      return Vector2( v1.x - n, v1.y - n )

    method op*( Vector2 v1, Real64 n ).Vector2:
      # Multiplies both components of v1 by 'n'.  Equivalent to
      #   v1 * Vector2(n,n)
      #
      # Examples:
      #   v = v * 5
      #   v *= 5
      return Vector2( v1.x * n, v1.y * n )

    method op/( Vector2 v1, Real64 n ).Vector2:
      # Divides both components of v1 by 'n'.  Equivalent to
      #   v1 / Vector2(n,n)
      #
      # Examples:
      #   v = v / 5
      #   v /= 5
      return Vector2( v1.x / n, v1.y / n )

    method op%( Vector2 v1, Real64 n ).Vector2:
      # Returns the Vector2 modulo of each component of 'v1' divided
      # by 'n'.  Equivalent to
      #   v1 % Vector2(n,n)
      #
      # Examples:
      #   v = v % 5
      #   v %= 5
      return Vector2( v1.x % n, v1.y % n )

    method op+( Real64 n, Vector2 v ).Vector2:
      # Equivalent to Vector2(n,n) + v
      #
      # Example:
      #   v = 5 + v
      return Vector2( v.x + n, v.y + n )

    method op-( Real64 n, Vector2 v ).Vector2:
      # Equivalent to Vector2(n,n) - v
      #
      # Example:
      #   v = 5 - v
      return Vector2( v.x - n, v.y - n )

    method op*( Real64 n, Vector2 v ).Vector2:
      # Equivalent to Vector2(n,n) * v
      #
      # Example:
      #   v = 5 * v
      return Vector2( v.x * n, v.y * n )

    method op/( Real64 n, Vector2 v ).Vector2:
      # Equivalent to Vector2(n,n) / v
      #
      # Example:
      #   v = 5 / v
      return Vector2( v.x / n, v.y / n )

    method op%( Real64 n, Vector2 v ).Vector2:
      # Equivalent to Vector2(n,n) % v
      #
      # Example:
      #   v = 5 % v
      return Vector2( v.x % n, v.y % n )

    method draw( Vector2 v, Color color, Render render_flags=Render.default ): native
      # Draws the specified color at the given point 'v'.
      #
      # Example:
      #   v.draw( Color.red )
endClass

#=====================================================================
# Corners
#=====================================================================
compound Corners( Vector2 top_left, Vector2 bottom_right )
  # Compound consisting of two corners.  Exists both as a means to 
  # create a box from two corners rather than a corner and a size and
  # as a way to store data such as UV coordinates that are "naturally"
  # represented as two points rather than as a point and a size.
  #
  # Example:
  #   local Corners c( center-0.5, center+0.5 )

singleton class CornersManager
  # Contains methods for operating on Corners compounds.
  METHODS
    method create_from( Real64 x1, Real64 y1, Real64 x2, Real64 y2 ).Corners:
      # Creates a Corners compound from the given top-left and bottom-
      # right coordinates.
      #
      # Example:
      #   local Corners c( x1, y1, x2, y2 )
      return Corners( Vector2(x1,y1), Vector2(x2,y2) )

    method create_from( Vector2 position ).Corners:
      # Creates a corners compound with 'position' as both the 
      # top-left and bottom-right coordinates.
      #
      # Example:
      #   local Corners c( pt )
      return Corners( position, position )

    method create_from( Box b ).Corners:
      # Creates a corners compound with the same dimensions as 'b'.
      #
      # Example:
      #   local Corners img_corners( img.bounding_box )
      return Corners( b.position, b.bottom_right )

    method to_String( Corners c ).String:
      # Returns a string representation of 'c'.
      return "[$(.2),$(.2) $(.2),$(.2)]" (c.top_left.x,c.top_left.y,...
          c.bottom_right.x, c.bottom_right.y )

    method bounding_box( Corners corners ).Box:
      # Returns a bounding box that encloses 'corners'.
      #
      # Example:
      #   bounding_box = corners.bounding_box
      return Box( corners.top_left, corners.size )

    method bounding_circle( Corners corners ).Circle:
      # Returns a bounding circle that encloses 'corners'.
      #
      # Example:
      #   bounding_circle = corners.bounding_circle
      return Box(corners.top_left, corners.size).bounding_circle

    method x1( Corners c ).Real64:
      # Returns the leftmost x coordinate of 'c'.
      #
      # Example:
      #   println( "left edge:$" (corners.x1) )
      return c.top_left.x

    method y1( Corners c ).Real64:
      # Returns the topmost y coordinate of 'c'.
      #
      # Example:
      #   println( "top edge:$" (corners.y1) )
      return c.top_left.y

    method x2( Corners c ).Real64:
      # Returns the rightmost x coordinate of 'c'.
      #
      # Example:
      #   println( "right edge:$" (corners.x2) )
      return c.bottom_right.x

    method y2( Corners c ).Real64:
      # Returns the bottommost y coordinate of 'c'.
      #
      # Example:
      #   println( "bottom edge:$" (corners.y2) )
      return c.bottom_right.y

    method size( Corners c ).Vector2:
      # Returns the size of 'c' as a Vector2.
      #
      # Example:
      #   println( "Dimensions: $" (corners.size) )
      return c.bottom_right - c.top_left

    method transformed( Corners corners, Transform xform ).Quad: native
      # Applies the given transformation to the given corners.
      # Note that the result is type Quad, not type Corners.
      #
      # Example:
      #   quad = corners.transformed( Transform().rotated(pi/2) )

    method op+( Corners corners, Vector2 v ).Corners:
      # Shifts the position of 'corners' by +v.
      #
      # Example:
      #   corners = corners + origin
      return Corners( corners.top_left + v, corners.bottom_right + v )

    method op-( Corners corners, Vector2 v ).Corners:
      # Shifts the position of 'corners' by -v.
      #
      # Example:
      #   corners = corners - origin
      return Corners( corners.top_left - v, corners.bottom_right - v )

    method op*( Corners corners, Vector2 n ).Corners:
      # Scales the "vertices" of 'corners' by 'n'.
      #
      # Example:
      #   corners = corners * scale
      return Corners( corners.top_left*n, corners.bottom_right * n )

    method op*( Corners corners, Real64 n ).Corners:
      # Scales the "vertices" of 'corners' by 'n'.
      #
      # Example:
      #   corners = corners * k
      return Corners( corners.top_left*n, corners.bottom_right * n )

    method op/( Corners corners, Vector2 n ).Corners:
      # Scales the "vertices" of 'corners' by '1/n'.
      #
      # Example:
      #   corners = corners / scale
      return Corners( corners.top_left/n, corners.bottom_right / n )

    method op/( Corners corners, Real64 n ).Corners:
      # Scales the "vertices" of 'corners' by '1/n'.
      #
      # Example:
      #   corners = corners / k
      return Corners( corners.top_left/n, corners.bottom_right / n )

endClass

#=====================================================================
# Box
#=====================================================================
compound Box( Vector2 position, Vector2 size )
  # Compound representing an abstract 2D box with a top-left 
  # 'position' and a total size.  Used for sub-image specification, 
  # collision physics, and the like.
  #
  # The coordinates and dimensions of a Box use a continuous rather
  # than discrete interval, meaning that a box at position (0,0)
  # and having size (5,10) will have a bottom-right coordinate of 
  # (5,10) and not (4,9).
  #
  # Example:
  #   local Box recticle( view.size/2 - 10, Vector2(20,20) )

singleton class BoxManager
  # Contains methods for operating on Box compounds.
  METHODS
    method create_from( Vector2 size ).Box:
      # Creates a Box compound with the given size and position 
      # (0,0).
      #
      # Example:
      #   local Box screen_region( view.size )
      return Box( Vector2(0,0), size )

    method create_from( Corners c ).Box:
      # Creates a Box compound with the given corners.
      #
      # Example:
      #   local Box recticle( Corners(view.size/2 - 10, view.size/2 + 10) )
      return Box( c.top_left, c.size )

    method create_from( Real64 x, Real64 y, Real64 width, Real64 height ).Box:
      # Creates a Box compound with the given position and size.
      #
      # Example:
      #   local Box bounding_box(x,y,64,64)
      return Box( Vector2(x,y), Vector2(width,height) )

    method to_String( Box box ).String:
      # Returns a string representation of 'box'.
      return "[$(.2),$(.2) $(.2)x$(.2)]" (box.position.x,box.position.y,box.size.x,box.size.y)

    method transformed( Box box, Transform xform ).Quad: native
      # Applies the given transformation to the given box.
      # Note that the result is a Quad, not a Box.
      #
      # Example:
      #   quad = box.transformed( Transform().rotated(pi/2) )

    method op+( Box box, Vector2 v ).Box:
      # Shifts the position of 'box' by +v.
      #
      # Examples:
      #   new_pos = box + offset 
      #   box += offset 
      return Box( box.position + v, box.size )

    method op-( Box box, Vector2 v ).Box:
      # Shifts the position of 'box' by -v.
      #
      # Examples:
      #   new_pos = box - offset 
      #   box -= offset 
      return Box( box.position - v, box.size )

    method op*( Box box, Vector2 n ).Box:
      # Scales the "vertices" of 'box' by 'n'.
      #
      # Examples:
      #   b3 = b2 * b1 
      #   box *= scale
      return Box( box.position*n, box.size*n )

    method op*( Box box, Real64 n ).Box:
      # Scales the "vertices" of 'box' by 'n'.
      #
      # Examples:
      #   b2 = b1 * factor
      #   box *= factor 
      return Box( box.position*n, box.size*n )

    method op/( Box box, Vector2 n ).Box:
      # Scales the "vertices" of 'box' by '1/n'.
      #
      # Examples:
      #   b2 = b1 / scale
      #   box /= scale 
      return Box( box.position/n, box.size/n )

    method op/( Box box, Real64 n ).Box:
      # Scales the "vertices" of 'box' by '1/n'.
      #
      # Examples:
      #   b1 = b1 / factor
      #   box /= factor 
      return Box( box.position/n, box.size/n )

    method scaled( Box box, Vector2 factor ).Box:
      # Scales the size of 'box' by 'factor' without affecting the position.
      #
      # Example:
      #   half_height = box.scaled( Vector2(1.0,0.5) )
      return Box( box.position, box.size * factor )

    method scaled( Box box, Real64  factor ).Box:
      # Scales the size of 'box' by 'factor' without affecting the position.
      #
      # Example:
      #   half_size = box.scaled( 0.5 )
      return Box( box.position, box.size * factor )

    method x1( Box box ).Real64:
      # Returns the leftmost x coordinate of 'box'.
      #
      # Example:
      #   println( "left edge:$" (box.x1) )
      return box.position.x

    method y1( Box box ).Real64:
      # Returns the topmost y coordinate of 'box'.
      #
      # Example:
      #   println( "top edge:$" (box.y1) )
      return box.position.y

    method x2( Box box ).Real64:
      # Returns the rightmost x coordinate of 'box'.
      #
      # Example:
      #   println( "right edge:$" (box.x2) )
      return box.position.x + box.size.x

    method y2( Box box ).Real64:
      # Returns the bottommost y coordinate of 'box'.
      #
      # Example:
      #   println( "bottom edge:$" (box.y2) )
      return box.position.y + box.size.y

    method top_left( Box box ).Vector2:
      # Returns the top-left corner of 'box'.
      #
      # Example:
      #   println( box.top_left )
      return box.position

    method top_right( Box box ).Vector2:
      # Returns the top-right corner of 'box'.
      #
      # Example:
      #   println( box.top_right )
      return Vector2( x2(box), box.position.y )

    method bottom_right( Box box ).Vector2:
      # Returns the bottom-right corner of 'box'.
      #
      # Example:
      #   println( box.bottom_right )
      return box.position + box.size

    method bottom_left( Box box ).Vector2:
      # Returns the bottom-left corner of 'box'.
      #
      # Example:
      #   println( box.bottom_left )
      return Vector2( box.position.x, y2(box) )

    method width( Box box ).Real64:
      # Returns the width of 'box'.
      #
      # Example:
      #   println( box.width )
      return box.size.x

    method height( Box box ).Real64:
      # Returns the height of 'box'.
      #
      # Example:
      #   println( box.height )
      return box.size.y

    method center( Box box ).Vector2:
      # Returns the center point of 'box'.
      #
      # Example:
      #   local Vector2 sprite_center = sprite.bounding_box.center
      return box.position + box.size / 2.0

    method area( Box box ).Real64:
      # Returns the area of 'box' (width * height).
      #
      # Example:
      #   println( box.area ) 
      return box.size.x * box.size.y

    method contains( Box box, Vector2 pt ).Logical:
      # Returns "true" if 'box' contains the given point.
      #
      # Example:
      #   println( actor.bounding_box.contains(Input.mouse_position) )
      local Real64 x = pt.x
      local Real64 y = pt.y
      if (x < box.position.x or y < box.position.y) return false
      if (x >= box.x2 or y >= box.y2) return false
      return true

    method contains( Box box1, Box box2 ).Logical:
      # Returns true if 'box1' contains 'box2'.  An exactly overlapping 'box2'
      # would count as being contained within 'box1'.
      if (box2.x1 < box1.x1 or box2.x2 > box1.x2) return false
      if (box2.y1 < box1.y1 or box2.y2 > box1.y2) return false
      return true

    method intersects( Box box1, Box box2 ).Logical:
      # Returns "true" if rectangles box1 and box2 intersect at all.
      #
      # Example:
      #   if (actor1.bounding_box.intersects(actor2.bounding_box)) ...
      if (x1(box1) >= x2(box2)) return false
      if (x2(box1) <= x1(box2)) return false
      if (y1(box1) >= y2(box2)) return false
      if (y2(box1) <= y1(box2)) return false
      return true

    method intersection( Box box1, Box box2 ).Box:
      # Returns the box defining the area that is common to both
      # 'box1' and 'box2'.  If the result's size is zero then the 
      # rectangles do not overlap.
      #
      # Example:
      #   collision_region = actor1.bounding_box.intersection(actor2.bounding_box)
      #   if (collision_region.area?) ...
      local Real64 x1 = box1.position.x
      local Real64 y1 = box1.position.y
      local Real64 x2 = x2(box1)
      local Real64 y2 = y2(box1)

      local Real64 r2_x1 = box2.position.x
      local Real64 r2_y1 = box2.position.y
      local Real64 r2_x2 = x2(box2)
      local Real64 r2_y2 = y2(box2)

      if (x1 < r2_x1) x1 = r2_x1
      if (y1 < r2_y1) y1 = r2_y1
      if (x2 > r2_x2) x2 = r2_x2
      if (y2 > r2_y2) y2 = r2_y2

      if (x1 > x2 or y1 > y2) 
        # will result in zero area
        x2 = x1; y2 = y1
      endIf

      return Box( Corners(x1, y1, x2, y2) )

    method expanded( Box box, Real64 per_side ).Box:
      # Returns a box that is 'per_side' units larger on every 
      # side.
      #
      # Example:
      #   padded_box = box.expanded(16)
      local Vector2 pos = box.position - per_side
      local Vector2 size = box.size + 2 * per_side
      return Box( pos, size )

    method expanded( Box box, Vector2 amount ).Box:
      # Returns a box that is "amount.x" units larger on the
      # left and right sides and "amount.y" units larger on the top
      # and bottom.
      #
      # Example:
      #   padded_box = box.expanded(border_size)
      local Vector2 pos = box.position - amount
      local Vector2 size = box.size + amount * 2
      return Box( pos, size )

    method cropped( Box box, Real64 per_side ).Box:
      # Returns a box that is 'per_side' units smaller on every
      # side.
      #
      # Example:
      #   smaller_box = box.cropped(16)
      local Vector2 top_left = box.position + per_side
      local Vector2 bottom_right = box.bottom_right - per_side
      return Box( Corners(top_left, bottom_right) )

    method cropped( Box box, Vector2 amount ).Box:
      # Returns a box that is smaller on the left and right 
      # sides by "amount.x" and is smaller on the top and bottom
      # sides by "amount.y".
      #
      # Example:
      #   smaller_box = box.cropped(border_size)
      local Vector2 top_left = box.position + amount
      local Vector2 bottom_right = box.bottom_right - amount
      return Box( Corners(top_left, bottom_right) )

    method enclosing( Box b, Vector2 pt ).Box:
      # Returns a box just big enough to contain the given
      # box and the given point.
      local var position = b.position
      local Real64 x1 = position.x
      local Real64 y1 = position.y
      local Real64 x2 = b.x2
      local Real64 y2 = b.y2

      local Real64 pt_x = pt.x
      local Real64 pt_y = pt.y

      return Box( Corners(min(x1,pt_x), min(y1,pt_y), max(x2,pt_x), max(y2,pt_y)) )

    method enclosing( Box box1, Box box2 ).Box:
      # Returns a box just big enough to contain both given
      # rectangles.
      return box1.enclosing(box2.position).enclosing(box2.bottom_right)

    method bounding_circle( Box box ).Circle:
      # Creates a circle just big enough to contain the given box.
      #
      # Example:
      #   hit_zone = sprite.bounding_circle
      local var center = box.center
      return Circle( center, (box.position - center).magnitude )

    method fill( Box box, Color color ):
      # Draws 'box' to the screen filled with the given color.
      #
      # Example:
      #   box.fill( COLOR.red )
      Quad(box).fill( ColorGradient(color) )

    method fill( Box box, ColorGradient colors ):
      # Draws 'box' to the screen as a gradient fill.  The four colors
      # are assigned clockwise starting with the top-left corner.
      Quad(box).fill( colors )

    method draw( Box box, Color color ):
      # Draws an outline of 'box' to the screen in the given color.
      #
      # Example:
      #   box.draw( COLOR.white )
      local Real64 x1 = box.position.x
      local Real64 y1 = box.position.y
      local Real64 x2 = box.x2 - 1
      local Real64 y2 = box.y2 - 1
      local var w = box.width
      local var h = box.height
      #Line(x1,y1,x2,y1).draw( color )
      #Line(x2,y1,x2,y2).draw( color )
      #Line(x2,y2,x1,y2).draw( color )
      #Line(x1,y2,x1,y1).draw( color )
      Box(x1,y1,w,1).fill(color)
      Box(x1,y2,w,1).fill(color)
      Box(x1,y1+1,1,h-2).fill(color)
      Box(x2,y1+1,1,h-2).fill(color)
endClass

#=====================================================================
# Quad
#=====================================================================
compound Quad( Vector2 top_left, Vector2 top_right, Vector2 bottom_right, Vector2 bottom_left )
  # Defines an abstract geometric quadrangle composed of four vertices.

singleton class QuadManager
  # Contains methods for operating on Quad compounds.
  METHODS
    method create_from( Box box ).Quad:
      # Creates a Quad with the same position and size as the given 
      # box.
      local Real64 x1 = box.x1
      local Real64 y1 = box.y1
      local Real64 x2 = box.x2
      local Real64 y2 = box.y2
      return Quad( Vector2(x1,y1), Vector2(x2,y1), Vector2(x2,y2), Vector2(x1,y2) )

    method create_from( Corners corners ).Quad:
      local Real64 x1 = corners.x1
      local Real64 y1 = corners.y1
      local Real64 x2 = corners.x2
      local Real64 y2 = corners.y2
      return Quad( Vector2(x1,y1), Vector2(x2,y1), Vector2(x2,y2), Vector2(x1,y2) )

    method to_String( Quad q ).String:
      # Returns a string representation of 'q'.
      return "[$,$,$,$]" (q.top_left, q.top_right, q.bottom_right, q.bottom_left)

    method bounding_box( Quad quad ).Box:
      # Returns a bounding box that encloses 'quad'.
      #
      # Example:
      #   bounding_box = quad.bounding_box
      return quad.top_left.bounding_box.enclosing(quad.top_right).enclosing(quad.bottom_right).enclosing(quad.bottom_left)

    method bounding_circle( Quad quad ).Circle:
      # Returns a bounding circle that encloses 'quad'.
      #
      # Example:
      #   bounding_circle = quad.bounding_circle
      return quad.top_left.bounding_circle.enclosing(quad.top_right).enclosing(quad.bottom_right).enclosing(quad.bottom_left)

    method transformed( Quad quad, Transform xform ).Quad: native
      # Applies the given transformation to the given quad.
      #
      # Example:
      #   quad = quad.transformed( Transform().rotated(pi/2) )

    method op+( Quad quad, Vector2 n ).Quad:
      # Shifts the vertices of 'quad' by n.
      #
      # Examples:
      #   quad2 = quad1 + n
      #   quad += n
      return Quad( quad.top_left+n, quad.top_right+n, quad.bottom_right+n, quad.bottom_left+n )

    method op-( Quad quad, Vector2 n ).Quad:
      # Shifts the vertices of 'quad' by -n.
      #
      # Examples:
      #   quad2 = quad1 - n
      #   quad -= n
      return Quad( quad.top_left-n, quad.top_right-n, quad.bottom_right-n, quad.bottom_left-n )

    method op*( Quad quad, Vector2 n ).Quad:
      # Scales the vertices of 'quad' by n.
      #
      # Examples:
      #   quad2 = quad1 * n
      #   quad *= n
      return Quad( quad.top_left*n, quad.top_right*n, quad.bottom_right*n, quad.bottom_left*n )

    method op*( Quad quad, Real64 n ).Quad:
      # Scales the vertices of 'quad' by n.
      #
      # Examples:
      #   quad2 = quad1 * n
      #   quad *= n
      return Quad( quad.top_left*n, quad.top_right*n, quad.bottom_right*n, quad.bottom_left*n )

    method op/( Quad quad, Vector2 n ).Quad:
      # Scales the vertices of 'quad' by 1/n.
      #
      # Examples:
      #   quad2 = quad1 / n
      #   quad /= n
      return Quad( quad.top_left/n, quad.top_right/n, quad.bottom_right/n, quad.bottom_left/n )

    method op/( Quad quad, Real64 n ).Quad:
      # Scales the vertices of 'quad' by 1/n.
      #
      # Examples:
      #   quad2 = quad1 / n
      #   quad /= n
      return Quad( quad.top_left/n, quad.top_right/n, quad.bottom_right/n, quad.bottom_left/n )

    method fill( Quad quad, Color color ):
      # Draws 'q' to the screen filled with the given color.
      #
      # Example:
      #   quad.fill( Color.red )
      fill( quad, ColorGradient(color) )

    method fill( Quad quad, ColorGradient colors, Render render_flags=Render.default ): native
      # Draws 'q' to the screen as a gradient fill.  The four colors in the gradient
      # are assigned clockwise starting with the first vertex.

    method draw( Quad q, Color color ):
      # Draws an outline of 'q' to the screen in the given color.
      #
      # Example:
      #   quad.draw( Color.black )
      Line(q.top_left,q.top_right).draw( color )
      Line(q.top_right,q.bottom_right).draw( color )
      Line(q.bottom_right,q.bottom_left).draw( color )
      Line(q.bottom_left,q.top_left).draw( color )
endClass

#=====================================================================
# Triangle
#=====================================================================
compound Triangle( Vector2 a, Vector2 b, Vector2 c )
  # Defines an abstract geometric triangle composed of three vertices.

singleton class TriangleManager
  # Contains methods for operating on Triangle compounds.
  METHODS
    method to_String( Triangle t ).String:
      # Returns a string representation of 't'.
      return "[$,$,$]" (t.a, t.b, t.c)

    method bounding_box( Triangle t ).Box:
      # Returns a bounding box that encloses 't'.
      #
      # Example:
      #   bounding_box = triangle.bounding_box
      return t.a.bounding_box.enclosing(t.b).enclosing(t.c)

    method bounding_circle( Triangle t ).Circle:
      # Returns a bounding circle that encloses 't'.
      #
      # Example:
      #   bounding_circle = triangle.bounding_circle
      return t.a.bounding_circle.enclosing(t.b).enclosing(t.c)

    method transformed( Triangle t, Transform xform ).Triangle: native
      # Applies the given transformation to the given triangle.
      #
      # Example:
      #   t = t.transformed( Transform().rotated(pi/2) )

    method op+( Triangle t, Vector2 n ).Triangle:
      # Shifts the vertices of 't' by n.
      #
      # Examples:
      #   t2 = t1 + n
      #   t += n
      return Triangle( t.a+n, t.b+n, t.c+n )

    method op-( Triangle t, Vector2 n ).Triangle:
      # Shifts the vertices of 't' by -n.
      #
      # Examples:
      #   t2 = t1 - n
      #   t -= n
      return Triangle( t.a-n, t.b-n, t.c-n )

    method op*( Triangle t, Vector2 n ).Triangle:
      # Scales the vertices of 't' by n.
      #
      # Examples:
      #   t2 = t1 * n
      #   t *= n
      return Triangle( t.a*n, t.b*n, t.c*n )

    method op*( Triangle t, Real64 n ).Triangle:
      # Scales the vertices of 't' by n.
      #
      # Examples:
      #   t2 = t1 * n
      #   t *= n
      return Triangle( t.a*n, t.b*n, t.c*n )

    method op/( Triangle t, Vector2 n ).Triangle:
      # Scales the vertices of 't' by 1/n.
      #
      # Examples:
      #   t2 = t1 / n
      #   t /= n
      return Triangle( t.a/n, t.b/n, t.c/n )

    method op/( Triangle t, Real64 n ).Triangle:
      # Scales the vertices of 't' by 1/n.
      #
      # Examples:
      #   t2 = t1 / n
      #   t /= n
      return Triangle( t.a/n, t.b/n, t.c/n )

    method fill( Triangle t, Color color, Render render_flags=Render.default ):
      # Draws 't' to the screen filled with the given color.
      #
      # Example:
      #   t.fill( Color.red )
      fill( t, color, color, color, render_flags )

    method fill( Triangle t, Color c1, Color c2, Color c3, Render render_flags=Render.default ): native
      # Draws 't' to the screen with interpolated color values.

    method draw( Triangle t, Color color ):
      # Draws an outline of 't' to the screen in the given color.
      #
      # Example:
      #   t.draw( Color.black )
      Line(t.a,t.b).draw( color )
      Line(t.b,t.c).draw( color )
      Line(t.c,t.a).draw( color )
endClass

#=====================================================================
# Circle
#=====================================================================
compound Circle( Vector2 position, Real64 radius )
  # Defines an abstract circle as 'position' and 'radius'.
  # Note: Circle drawing requires many operations!

singleton class CircleManager
  # Contains methods for operating on Circle compounds.
  METHODS
    method enclosing( Circle circle, Vector2 v ).Circle:
      # Creates a circle just big enough to contain the given circle
      # and vector.
      #
      # Example:
      #   circle = circle.enclosing(pt)
      local var m = (v - circle.position).magnitude
      if (m > circle.radius) return Circle( circle.position, m )
      else return circle

    method enclosing( Circle c1, Circle c2 ).Circle:
      # Creates a circle just big enough to contain both given circles.
      #
      # Example:
      #   hit_zone = body.bounding_circle.enclosing(left_wing).enclosing(right_wing)
      local Line line( c1.position, c2.position )
      local var center = line.center
      local var r = (c1.position - center).magnitude
      r += max( c1.radius, c2.radius )
      return Circle( center, r )

    method to_String( Circle circle ).String:
      # Returns a string representation of 'circle'.
      return "@$,$R" (circle.position,circle.radius)

    method point_at( Circle circle, Radians angle ).Vector2:
      # Returns the point along the edge of the circle at the given angle.
      #
      # Example:
      #   one_oclock = circle.point_at( 2*pi/12 )
      return circle.position + Vector2( circle.radius, angle )

    method point_at( Circle circle, Degrees angle ).Vector2:
      # Returns the point along the edge of the circle at the given angle.
      #
      # Example:
      #   one_oclock = circle.point_at( Degrees(360.0/12.0) )
      return circle.position + Vector2( circle.radius, angle )

    method transformed( Circle circle, Transform xform ).Circle: native
      # Applies the given transformation to the given circle.
      # The result will be incorrect for scaling operations that do 
      # not preserve aspect ratio (e.g. same width with half height).
      # A future version of Plasmacore may address this.
      #
      # Example:
      #   circle = circle.transformed( Transform().rotated(pi/2) )

    method op+( Circle circle, Vector2 v ).Circle:
      # Shifts the position of 'circle' by +v.
      #
      # Examples:
      #   circle2 = circle1 + offset
      #   circle += offset
      return Circle( circle.position + v, circle.radius )

    method op-( Circle circle, Vector2 v ).Circle:
      # Shifts the position of 'circle' by -v.
      #
      # Examples:
      #   circle2 = circle1 - offset
      #   circle -= offset
      return Circle( circle.position - v, circle.radius )

    method op*( Circle circle, Real64 n ).Circle:
      # Scales the position and size of 'circle' by 'n'.
      #
      # Examples:
      #   circle2 = circle1 * k
      #   circle *= k
      return Circle( circle.position * n, circle.radius * n )

    method op/( Circle circle, Real64 n ).Circle:
      # Scales the position and size of 'circle' by '1/n'.
      #
      # Examples:
      #   circle2 = circle1 / k
      #   circle /= k
      return Circle( circle.position / n, circle.radius / n )

    method scaled( Circle circle, Real64 factor ).Circle:
      # Scales the radius of 'circle' by 'factor' without affecting
      # the position.
      #
      # Example:
      #   circle = circle.scaled(2)
      return Circle( circle.position, circle.radius * factor )

    method x1( Circle circle ).Real64:
      # Returns the leftmost coordinate of the given circle.
      #
      # Example:
      #   println( circle.x1 )
      return circle.position.x - circle.radius

    method y1( Circle circle ).Real64:
      # Returns the topmost coordinate of the given circle.
      #
      # Example:
      #   println( circle.y1 )
      return circle.position.y - circle.radius

    method x2( Circle circle ).Real64:
      # Returns the rightmost coordinate of the given circle.
      #
      # Example:
      #   println( circle.x2 )
      return circle.position.x + circle.radius

    method y2( Circle circle ).Real64:
      # Returns the bottommost coordinate of the given circle.
      #
      # Example:
      #   println( circle.y2 )
      return circle.position.y + circle.radius

    method intersects( Circle c1, Circle c2 ).Logical:
      # Returns "true" if c1 and c2 intersect.
      #
      # Example:
      #   if (circle1.intersects(circle2)) ...
      return c1.position.dot(c2.position) <= (c1.radius + c2.radius)^2

    method intersects( Circle circle, Line line ).Logical:
      # Returns true if 'line' and 'circle' intersect.
      #
      # Example:
      #   if (circle1.intersects(line)) ...
      return line.intersects(circle)

    method bounding_box( Circle circle ).Box:
      # Returns a box just big enough to contain the given circle.
      #
      # Example:
      #   local Box bounds = circle.bounding_box
      local var box = circle.radius
      return Box( Corners(-box,-box,box,box) ) + circle.position

    method draw( Circle circle, Color color, Real64 segments=(1.0/12.0) ):
      # Draws the given circle to the screen in the given color.
      #
      # Parameters:
      #   circle
      #     The circle to draw, centered at "circle.position" and with
      #     pixel radius "circle.radius".
      #
      #   color
      #     The color to draw the circle in.
      #
      #   segments [default: (1.0/12.0)]
      #     If whole - the number of segements.  
      #     If fractional -  the number of segements is dynamically determined 
      #     as this fraction of the circle's circumference.
      #
      # Example:
      #   Circle(view.size/2, 16).draw( Color.blue )
      if (segments < 1.0)
        local var circ = circle.radius * 2 * pi.value
        segments = floor( circ * segments )
      endIf
      local Real64 angle_step = pi.value * 2 / segments
      if (angle_step > pi.value/8) angle_step = pi.value/8
      local Vector2 first = circle.point_at(Radians(0))
      local Vector2 pt1 = first
      forEach (angle in angle_step..2*pi.value step angle_step)
        local Vector2 pt2 = circle.point_at(Radians(angle))
        Line(pt1,pt2).draw( color )
        pt1 = pt2
      endForEach
      Line(pt1,first).draw( color )
endClass


#=====================================================================
# Line
#=====================================================================
compound Line( Vector2 pt1, Vector2 pt2 )
  # Defines an abstract line as a 'pt1' and an 'pt2' coordinate 
  # pair.
  #
  # Example:
  #   local Line line( Vector2(0,0), view.size )


singleton class LineManager
  # Contains methods for operating on Line compounds.
  METHODS
    method create_from( Real64 x1, Real64 y1, Real64 x2, Real64 y2 ).Line:
      # Creates a Line from (x1,y1) to (x2,y2).
      #
      # Example:
      #   local Line line( x1, y2, x2, y2 )
      return Line( Vector2(x1,y1), Vector2(x2,y2) )

    method bounding_box( Line line ).Box:
      # Returns a box just big enough to contain the given
      # line.
      return line.pt1.bounding_box.enclosing( line.pt2 )

    method bounding_circle( Line line ).Circle:
      # Creates a circle just big enough to contain the given line.
      #
      # Example:
      #   hit_zone = line.bounding_circle
      return Circle( line.midpoint, line.length/2 )

    method to_String( Line line ).String:
      # Returns a string representation of 'line'.
      return "($(.2),$(.2))->($(.2),$(.2))" (line.pt1.x,line.pt1.y,line.pt2.x,line.pt2.y)

    method point_along( Line line, Real64 p ).Vector2:
      # Returns the point along the given line corresponding to
      # fraction 'p', where 0 <= p <= 1.0.
      #
      # Invariant:
      #   point_along(line,0.0) == line.pt1
      #   point_along(line,0.5) == line.center
      #   point_along(line,1.0) == line.pt2
      #
      # Example:
      #   three_quarters = line.point_along(0.75)
      local var delta = line.pt2 - line.pt1
      return line.pt1 + delta * p

    method center( Line line ).Vector2:
      # Returns the center point of the given line.
      #
      # Example:
      #   m = line.center
      return (line.pt1 + line.pt2) / 2.0

    method midpoint( Line line ).Vector2:
      # Returns the point in the middle of the given line.
      # Equivalent to center().
      #
      # Example:
      #   m = line.midpoint
      return (line.pt1 + line.pt2) / 2.0

    method length( Line line ).Real64:
      # Returns the length of the given line.
      #
      # Example:
      #   println( line.length )
      return (line.pt2 - line.pt1).magnitude

    method transformed( Line line, Transform xform ).Line: native
      # Applies the given transformation to the given vector.
      #
      # Example:
      #   line = line.transformed( Transform().rotated(pi/2) )

    method op+( Line line, Vector2 v ).Line:
      # Shifts the position of 'line' by +v.
      #
      # Examples:
      #   line2 = line1 + Vector2(5,0)
      #   line += Vector2(5,0)
      return Line( line.pt1 + v, line.pt2 + v )

    method op-( Line line, Vector2 v ).Line:
      # Shifts the position of 'line' by -v.
      #
      # Examples:
      #   line2 = line1 - Vector2(5,0)
      #   line -= Vector2(5,0)
      return Line( line.pt1 - v, line.pt2 - v )

    method op*( Line line, Vector2 n ).Line:
      # Scales the position of 'line' by n.
      #
      # Examples:
      #   line2 = line1 * Vector2(1024,768)
      #   line *= Vector2(1024,768)
      return Line( line.pt1 * n, line.pt2 * n )

    method op*( Line line, Real64 n ).Line:
      # Scales the position of 'line' by n.
      #
      # Examples:
      #   line2 = line1 * 2
      #   line *= 2
      return Line( line.pt1 * n, line.pt2 * n )

    method op/( Line line, Vector2 n ).Line:
      # Scales the position of 'line' by 1/n.
      #
      # Examples:
      #   line2 = line1 / Vector2(1024,768)
      #   line /= Vector2(1024,768)
      return Line( line.pt1 / n, line.pt2 / n )

    method op/( Line line, Real64 n ).Line:
      # Scales the position of 'line' by 1/n.
      #
      # Examples:
      #   line2 = line1 / 2
      #   line /= 2
      return Line( line.pt1 / n, line.pt2 / n )

    method intersection( Line line1, Line line2 ).Vector2:
      # Returns the point of intersection between line1 and line 2
      # or Vector2.invalid ("Vector2(NaN,NaN)") if there is no intersection.
      #
      # Example:
      #   local var intersection = line1.intersection(line2) 
      #   if (intersection != Vector2.invalid ) ...
      local var P1 = line1.pt1
      local var P2 = line1.pt2
      local var P3 = line2.pt1
      local var P4 = line2.pt2
      local var A = P2 - P1
      local var B = P4 - P3
      local var C = P3 - P1
      local var denom = B.cross(A)
      local var t0 = B.cross(C) / denom
      local var t1 = A.cross(C) / denom
      if (t0 < 0.0 or t0 > 1.0 or t1 < 0.0 or t1 > 1.0)
        return Vector2(NaN,NaN)
      endIf
      return P1 + t0 * A

    method intersects( Line line1, Line line2 ).Logical:
      # Returns true if line segments 'line1' and 'line2' intersect.
      # Use 'intersection' to determine the point of intersection.
      #
      # Example:
      #   if (line1.intersects(line2)) ...
      return line1.intersection(line2) != Vector2(NaN,NaN)

    method intersects( Line line, Circle circle ).Logical:
      # Returns true if 'line' and 'circle' intersect.
      #
      # Example:
      #   if (line.intersects(circle)) ...
      local var closest_pt = circle.position.clamped( line )
      return (circle.position.distance_to(closest_pt) <= circle.radius)

    method draw( Line line, Color color, Render render_flags=Render.default ): native
      # Draws the given line to the screen in the given color.
      #
      # Example:
      #   line.draw( Color.yellow )
endClass

#=====================================================================
# Bitmap
#=====================================================================

requisite class Bitmap
  # Pixel data wrapper for examining and manipulating image data.
  # Native layer implementations may load textures as Bitmap objects
  # first and then convert them into hardware-accelerated Images.

  #CLASS_METHODS
    #method load( String filename ).Bitmap:
      # Creates a Bitmap containing the pixel data from the specified 
      # file.  Currently only png and jpg files are supported.
      #filename = find( filename )
      #local Bitmap bmp
      #bmp = create_from( File(filename).to_bytes )

      #if (not bmp?) throw FileError( //Error loading "$".// (filename) )
      #return bmp

    #method create_from( Byte[] data ).Bitmap: native

  PROPERTIES
    data : Array<<Color>>
      # Single-dimensional array of Color values.  Values 
      # data[0 ..< width] are the first row, data[width ..< width*2]
      # are the second row, and so on.

    width : Int32
      # The width of this bitmap, in pixels.

    height : Int32
      # The height of this bitmap, in pixels.

  METHODS
    requisite method init( width, height ):
      # Creates a transparent black bitmap of the given width and
      # height.
      data = Array<<Color>>( width * height )

    method init( Vector2 pixel_size ):
      # Creates a transparent black bitmap of the given size.
      init( pixel_size.x, pixel_size.y )

    requisite method init( String filename ): native
      # Creates a Bitmap containing image data from the given
      # png or jpeg file.
      #System.force_garbage_collection
      #local Bitmap temp = load( filename )
      #data = temp.data
      #width = temp.width
      #height = temp.height

    method init( Byte[] raw_data ): native

    method init( Bitmap existing ):
      # Creates a bitmap that's an exact duplicate of an existing bitmap.
      init( existing, existing.bounding_box )

    method init( Bitmap existing, Box rect ):
      # Creates a bitmap that's a given subset of an existing bitmap.
      init( existing, rect.position, rect.size )

    method init( Bitmap existing, Vector2 top_left, Vector2 new_size ):
      # Creates a bitmap that's a given subset of an existing bitmap.
      local Box src_region = Box(existing.size).intersection(Box(top_left,new_size))
      if (src_region.area == 0) init(0,0); return

      init( src_region.size.x, src_region.size.y )
      existing.draw_to( this, -src_region.position.x, -src_region.position.y, false )

    method hash_code.Int32:
      return data.count

    method set( Bitmap existing ):
      # Sets this bitmap to reference the same data as another 
      # existing bitmap.  Note that the array of Color data is shared
      # rather than duplicated.
      data   = existing.data
      width  = existing.width
      height = existing.height

    method size.Vector2:
      # Returns the two-dimensional size of this bitmap, in pixels.
      return Vector2(width,height)

    method bounding_box.Box:
      # Returns the rectangular region occupied by this bitmap.
      # The 'position' of the resulting box is (0,0).
      return Box(Vector2(width,height))

    method clear( Color color = Color(0,0,0,255) ):
      # Clears all the pixels of this bitmap to be the given color
      # or opaque black by default.
      forEach (i of data) data[i] = color

    method get( Int32 x, Int32 y ).Color:
      return data[(y%height)*width + (x%width)]

    method plot( Int32 x, Int32 y, Color c ):
      data[(y%height)*width+(x%width)] = c

    method clear_channel( Color color, Int32 channel_mask ):
      # Clears a certain channel of this bitmap to the given color.
      #
      # Parameters:
      #   color
      #     The color to clear to.  Only the bits of the AARRGGBB 
      #     'color' that correspond to the set bits in 'channel_mask'
      #     are copied.
      #
      #   channel_mask
      #     A 32-bit AARRGGBB value where 1 bits indicate the color
      #     should be copied and 0 bits where it shouldn't.  For
      #     example, to clear the alpha channel to a:128 without
      #     affecting the red, green, or blue color values:
      #
      #       clear_channel( Color(0,0,0,128), 0xff000000 )
      #   
      local Int32 c = color.argb
      c &= channel_mask
      channel_mask = !channel_mask
      forEach (i of data) data[i] = Color((data[i].argb & channel_mask) | c)

    method draw( Int32 x, Int32 y ):
      # For native layer debugging purposes.  Performs a slow image 
      # draw using a draw(Vector2) call per pixel.
      local Int32 src_pos = 0
      forEach (j in 0..<height)
        forEach (i in 0..<width)
          Vector2(x+i,y+j).draw( data[src_pos] )
          src_pos++
        endForEach
      endForEach

    method draw( Vector2 pos ):
      # For native layer debugging purposes.  See draw(Int32,Int32).
      draw(pos.x,pos.y)

    method draw_to( Bitmap dest, Vector2 pos, Logical blend_alpha=true ):
      # Draws this bitmap to the given destination bitmap.  This is
      # operation is performed in software and is not intended for
      # heavy per-frame use.
      #
      # Parameters:
      #   dest 
      #     A bitmap to draw to.  Edge clipping is performed.
      #
      #   pos
      #     Where to place the top-left corner of this bitmap.
      #
      #   blend_alpha (default:true)
      #     Set to "true" if per-pixel alpha blending should be 
      #     performed.  Set to "false" to completely overrwrite
      #     destination pixels.
      draw_to( dest, pos.x, pos.y, blend_alpha )

    method draw_to( Bitmap dest, Int32 x, Int32 y, Logical blend_alpha=true ):
      # Draws this bitmap to the given destination bitmap.  This is
      # operation is performed in software and is not intended for
      # heavy per-frame use.
      #
      # Parameters:
      #   dest 
      #     A bitmap to draw to.  Edge clipping is performed.
      #
      #   x,y
      #     Where to place the top-left corner of this bitmap.
      #
      #   blend_alpha (default:true)
      #     Set to "true" if per-pixel alpha blending should be 
      #     performed.  Set to "false" to completely overrwrite
      #     destination pixels.
      local Box    draw_region = Box(x,y,width,height).intersection( dest.bounding_box )
      local Vector2 dest_pos = draw_region.position
      copy_pixels_to( ...
          (dest_pos.x - x), (dest_pos.y - y), 
          draw_region.width, draw_region.height,
          dest, 
          dest_pos.x, dest_pos.y,
          blend_alpha )

      #{
      local Int32 src_i  = (dest_pos.y - y) * width + (dest_pos.x - x)
      local Int32 dest_i = dest_pos.y * dest.width + dest_pos.x
      local Int32 copy_width = draw_region.size.x
      local Int32 dest_skip_width = dest.width - copy_width
      local Int32 src_skip_width = width - copy_width
      local var dest_data = dest.data

      if (blend_alpha)
        forEach (1..draw_region.size.y)
          forEach (1..copy_width)
            dest_data[dest_i] = Color( data[src_i], dest_data[dest_i] )
            dest_i++
            src_i++
          endForEach
          dest_i += dest_skip_width
          src_i += src_skip_width
        endForEach

      else
        forEach (1..draw_region.size.y)
          forEach (1..copy_width)
            dest_data[dest_i] = data[src_i]
            dest_i++
            src_i++
          endForEach
          dest_i += dest_skip_width
          src_i += src_skip_width
        endForEach
      endIf
      }#

    method copy_pixels_to( Int32 src_x, Int32 src_y, Int32 w, Int32 h, 
        Bitmap dest, Int32 dest_x, Int32 dest_y, Logical blend_alpha ): native
      # Internal use.

    method draw_column_to( Int32 column, Bitmap dest, Int32 x, Int32 y ):
      # Internal use.  Draws the specified column of this bitmap (0..<width) to 
      # the destination bitmap.
      column %= width
      x %= dest.width
      y %= dest.height

      local Box     draw_region = Box(x,y,1,height).intersection( dest.bounding_box )
      local Vector2 dest_pos = draw_region.position
      local Int32 src_i  = (dest_pos.y - y) * width + (dest_pos.x - x) + column
      local Int32 dest_i = dest_pos.y * dest.width + dest_pos.x
      local Int32 dest_pitch = dest.width
      local Int32 src_pitch = width
      local var dest_data = dest.data

      forEach (1..draw_region.size.y)
        dest_data[dest_i] = data[src_i] #& 0x00ffffff
        dest_i += dest_pitch
        src_i += src_pitch
      endForEach

    method draw_row_to( Int32 row, Bitmap dest, Int32 x, Int32 y ):
      # Internal use.  Draws the specified row of this bitmap (0..<height) to 
      # the destination bitmap.
      row %= height
      x %= dest.width
      y %= dest.height

      local Box     draw_region = Box(x,y,width,1).intersection( dest.bounding_box )
      local Vector2 dest_pos = draw_region.position
      local Int32 src_i  = ((dest_pos.y - y) + row) * width + (dest_pos.x - x)
      local Int32 dest_i = dest_pos.y * dest.width + dest_pos.x
      local var dest_data = dest.data

      forEach (1..draw_region.size.x)
        dest_data[dest_i] = data[src_i] #& 0x00ffffff
        dest_i++
        src_i++
      endForEach

    method draw_channel_to( Bitmap dest, Int32 x, Int32 y, Int32 channel_mask ):
      # Draws selected bits of this bitmap to the destination.  No 
      # alpha blending is performed.
      #
      # Parameters:
      #   dest 
      #     A bitmap to draw to.  Edge clipping is performed.
      #
      #   x,y
      #     Where to place the top-left corner of this bitmap.
      #
      #   channel_mask
      #     A 32-bit AARRGGBB value where 1 bits indicate the color
      #     should be copied and 0 bits where it shouldn't.  For
      #     example, to copy this bitmap's alpha values without
      #     disturbing the color values of the image:
      #
      #       draw_channel_to( dest, 0, 0, 0xff000000 )
      local Box    draw_region = Box(x,y,width,height).intersection( dest.bounding_box )
      local Vector2 dest_pos = draw_region.position
      local Int32 src_i  = (dest_pos.y - y) * width + (dest_pos.x - x)
      local Int32 dest_i = dest_pos.y * dest.width + dest_pos.x
      local Int32 copy_width = draw_region.size.x
      local Int32 dest_skip_width = dest.width - copy_width
      local Int32 src_skip_width = width - copy_width
      local var dest_data = dest.data

      local Int32 inverse_channel_mask = !channel_mask

      forEach (1..draw_region.size.y)
        forEach (1..copy_width)
          dest_data[dest_i] = Color((dest_data[dest_i].argb & inverse_channel_mask)...
              | (data[src_i].argb & channel_mask))
          dest_i++
          src_i++
        endForEach
        dest_i += dest_skip_width
        src_i += src_skip_width
      endForEach

    method non_transparent_region.Box:
      # Returns a box just large enough to enclose all pixels 
      # that aren't completely transparent.  If the area of the
      # resulting box is zero then this bitmap is completely
      # transparent.
      #
      # Invariant:
      #   result == old.intersection(result)
      local Int32 x1=0, x2=width-1
      local Int32 y1=0, y2=height-1
      while (x1 < x2 and column_transparent(x1)) x1++
      while (x1 < x2 and column_transparent(x2)) x2--
      while (y1 < y2 and row_transparent(y1)) y1++
      while (y1 < y2 and row_transparent(y2)) y2--
      return Box( Corners(x1,y1,x2+1,y2+1) )

    method column_transparent( Int32 x ).Logical:
      # Returns "true" if column 'x' (where x is 0 ..< width) 
      # contains completely transparent pixel values.
      local Int32 src_pos = x
      forEach (1..height)
        if (data[src_pos].alpha != 0) return false
        src_pos += width
      endForEach
      return true

    method row_transparent( Int32 y ).Logical:
      # Returns "true" if row 'y' (where y is 0 ..< height) 
      # contains completely transparent pixel values.
      local Int32 src_pos = y * width
      forEach (1..width)
        if (data[src_pos].alpha != 0) return false
        src_pos++
      endForEach
      return true

    method add_transparent_outline:
      # Adjusts this bitmap's data to include a 1-pixel transparent
      # black border on each edge.

      # create a new bitmap 1 pixel bigger in each dimension
      local Bitmap new_bmp( width + 2, height + 2 )
      draw_to( new_bmp, 1, 1, false )

      # reset my values from the new bitmap
      data = new_bmp.data
      width = new_bmp.width
      height = new_bmp.height


    method split_into_tiles( Int32 tiles_wide, Int32 tiles_high ).Bitmap[]:
      # Splits this Bitmap into an array of separate Bitmap tiles.
      #
      # Returns a list of Bitmap objects where index 0 is 
      # the top-left tile, index[tiles_wide-1] is the top-right 
      # tile, and so on.
      local Bitmap[] tiles( tiles_wide * tiles_high )

      local Vector2 tile_size( width / tiles_wide, height / tiles_high )

      forEach (j in 0..<tiles_high)
        forEach (i in 0..<tiles_wide)
          tiles.add( Bitmap( this, Vector2(i,j)*tile_size, tile_size ) )
        endForEach
      endForEach

      return tiles

    method split_into_image_tiles( Int32 tiles_wide, Int32 tiles_high ).Image[]:
      # Splits this Bitmap into an array of separate Image tiles.  When
      # you call Image::split_into_tiles(), the original image is placed
      # whole into the current texture sheet.  When you call this method
      # (Bitmap::split_into_image_tiles()), the texture is actually split
      # into pieces to allow them to more easily fit into image sheets.
      #
      # Returns a list of Image objects where index 0 is 
      # the top-left tile, index[tiles_wide-1] is the top-right 
      # tile, and so on.
      local Image[] tiles( tiles_wide * tiles_high )

      local Vector2 tile_size( width / tiles_wide, height / tiles_high )

      forEach (j in 0..<tiles_high)
        forEach (i in 0..<tiles_wide)
          tiles.add( Image( Bitmap(this, Vector2(i,j)*tile_size, tile_size) ) )
        endForEach
      endForEach

      return tiles

    method fill( Box box, Color color, Logical blend_alpha=false ):
      # Fills the given box with the given color, optionally
      # performing alpha-blending [default: false].
      box = box.intersection( this.bounding_box )
      if (box.area == 0) return

      local Int32 pos = Int32(box.position.y) * width + Int32(box.position.x)
      local Int32 fill_width = box.size.x
      local Int32 skip_width = width - fill_width

      if (blend_alpha)
        forEach (1..box.size.y)
          forEach (1..fill_width)
            data[pos] = Color( color, data[pos] )
            pos++
          endForEach
          pos += skip_width
        endForEach
      else
        forEach (1..box.size.y)
          forEach (1..fill_width) data[pos] = color; pos++
          pos += skip_width
        endForEach
      endIf

    method draw( Box box, Color color, Logical blend_alpha ):
      # Draws the outline of the given box in the given color,
      # optionally performing alpha-blending (default: true).
      local Int32 x = box.position.x
      local Int32 y = box.position.y
      local Int32 w = box.size.x
      local Int32 h = box.size.y
      fill( Box( x, y, w, 1 ), color, blend_alpha )
      fill( Box( x, y+h-1, w, 1 ), color, blend_alpha )
      fill( Box( x, y+1, 1, h-2 ), color, blend_alpha )
      fill( Box( x+w-1, y+1, 1, h-2 ), color, blend_alpha )
endClass

#=====================================================================
# Image
#=====================================================================
enum Handle
  # Enumeration of valid "handle" or "hot spot" categories for drawing
  # images.  See Image::handle().
  CATEGORIES
    top_left, top_right, bottom_left, bottom_right
    left_center, right_center, top_center, bottom_center
    center
endEnum

class GenericImage
  # Base aspect of both Image and CompositeImage.

  PROPERTIES
    size   : Vector2
      # The nominal size of the given image, in pixels.  Change
      # 'size' if you want the image's standard size to be a
      # given number of pixels or change 'scale' if you want the 
      # image to be proportionally larger or smaller.

    scale(1.0,1.0) : Vector2
      # The size multiplier for rendering, (1.0,1.0) by default.
      # Setting "scale = Vector2(2.0,0.5)" would cause the image to
      # render at twice the width and half the height.  Change
      # 'size' instead if you want to achieve particular pixel
      # dimensions.

    handle : Vector2
      # Specifies the drawing and rotation origin of this image.  
      # This can be set to a pixel value relative to the upper-left
      # of the image (0,0) or a Handle category such as 
      # "Handle.center" or "Handle.bottom_center".  The handle
      # is the top-left corner (0,0) by default.

    color(0xffffffff) : Color
      # The multiplier for each pixel in this image as it's drawn.
      # The default color of Color(255,255,255,255) ensures that 
      # the image will appear "normal".  A color of 
      # Color(255,255,0) would not draw any of the blue channel, 
      # making a grey-scale image appear to be tinted yellow.  A color
      # of Color(255,255,255,128) would draw the image halfway
      # transparent.

    render_flags : Render
      # Any combination of Render constants, or 0 for no special
      # rendering options.
      #
      # Example:
      #   ghost.render_flags = (Render.overexpose | Render.fixed_color)

    blend=Blend.normal : Blend
      # Blending mode.  See class BlendManager for more examples.

    angle  : Radians
      # The angle property variable.  This may be set to a new
      # Radians or Degrees value.  

    hflip : Logical
      # Specifies that an image should be flipped horizontally when
      # drawn.  This mirroring is applied before the image is rotated
      # and does not affect the spatial positioning.

    vflip : Logical
      # Specifies that an image should be flipped vertically when
      # drawn.  This mirroring is applied before the image is rotated
      # and does not affect the spatial positioning.

    alpha : Int32
      # Internal use. Prevents 'alpha' from being declared again by mistake.


  METHODS
    method handle( Vector2 new_handle ):
      # Handle property-set.
      &handle = new_handle

    method handle( Handle h ):
      # Handle property-set.
      which (h)
        case Handle.top_left:      &handle=Vector2( 0, 0 )
        case Handle.top_right:     &handle=Vector2( size.x, 0 )
        case Handle.bottom_left:   &handle=Vector2( 0, size.y )
        case Handle.bottom_right:  &handle=Vector2( size.x, size.y )
        case Handle.left_center:   &handle=Vector2( 0, size.y/2 )
        case Handle.right_center:  &handle=Vector2( size.x, size.y/2 )
        case Handle.top_center:    &handle=Vector2( size.x/2, 0 )
        case Handle.bottom_center: &handle=Vector2( size.x/2, size.y )
        case Handle.center:        &handle=Vector2( size.x/2, size.y/2 )
        others: throw InvalidOperandError()
      endWhich

    method must_recalculate_transforms( Logical setting ):
      noAction

    method angle( Radians new_angle ):
      # Angle property-set.
      &angle = new_angle

    method angle( Degrees deg ):
      # Angle property-set.
      &angle = to_Radians(deg)

    method scale( Vector2 new_scale ):
      # Scale property-set.
      &scale = new_scale

    method scale( Real64 uniform_scale ):
      # Scale property-set.
      &scale = Vector2(uniform_scale,uniform_scale)

    method point_filter( Logical setting ):
      # Turns point filtering on or off in the render flags.  "on" 
      # selects nearest-neighbor point filtering; "off" selects 
      # linear filtering (the Image default).
      if (setting) render_flags |= Render.point_filter
      else render_flags &= !Render.point_filter

    method point_filter.Logical:
      # Returns "true" if "point_filter" is set in the render flags.
      return (render_flags & Render.point_filter).flags != 0

    method fixed_color( Logical setting ):
      # Turns fixed-color drawing on or off in the render flags.
      if (setting) render_flags |= Render.fixed_color
      else render_flags &= !Render.fixed_color

    method fixed_color.Logical:
      # Returns "true" if "fixed_color" is set in the render flags.
      return (render_flags & Render.fixed_color).flags != 0

    method texture_wrap( Logical setting ):
      # Turns texture wrapping on or off in the render flags.
      if (setting) render_flags |= Render.texture_wrap
      else render_flags &= !Render.texture_wrap

    method texture_wrap.Logical:
      # Returns "true" if "texture_wrap" is set in the render flags.
      return (render_flags & Render.texture_wrap).flags != 0

    method alpha.Int32:
      # Alpha property-get method - returns the alpha component
      # (0-255) of the current color multiplier.
      return color.argb.right_shifted(24)

    method alpha( Int32 new_alpha ):
      # Alpha property-set method - sets the alpha component
      # of this image's color multiplier.
      #
      # new_alpha should be 0 (transparent) through 255 (opaque).
      local Int32 c = color.argb
      c &= 0xffffff
      c |= new_alpha.left_shifted(24)
      color = Color( c )

    method alpha( Real64 new_alpha ):
      # Alpha property-set method - sets the alpha component
      # of this image's color multiplier.
      #
      # new_alpha should be 0.0 (transparent) through 1.0 (opaque).
      alpha = Int32(new_alpha*255)

    method bounding_box.Box:
      # Returns the rectangular region nominally occupied by this 
      # image at its size and scale.  The 'position' of the 
      # resulting box is (0,0).
      return Box( size * scale )

    method bounding_circle.Circle:
      # Returns the circular region enclosing this 
      # image at its size and scale.  The 'position' of the 
      # resulting box is (0,0).
      return bounding_box.bounding_circle

    method draw( Real64 x, Real64 y ):
      # Draws this image with its handle (origin) at (x,y).
      draw( Vector2(x,y) )

    method draw( Vector2 pos ): abstract
      # Draws this image at the given position.

    method clear( Color c=Color.black ):
      bounding_box.fill(c)

    method release:
      # Releases the hardware resources associated with this image.
      # This will be called automatically at some point when the image
      # is no longer referenced.
endClass

#=====================================================================
# GUIManager
#=====================================================================
requisite singleton class GUIManager : Panel
  PROPERTIES
    app_initialized : Logical
      # Kept at "false" if an exception is thrown in init(), in which 
      # case neither update() nor draw() are called.

    update_list(1) : Component[]
      # Internal use.

    

  METHODS
    method init:
      listen_to( Input )

    method update:
      if (app_initialized)
        try
          Input.update
          forEach (view in update_list.copy_from(components)) 
            if (view.active) view.update
          endForEach
        catch (Error err)
          trace( err.to_String )
        endTry
      endIf

    method draw-wrapper:
      # cancel out normal draw-wrapper
      draw

    method draw:
      #TextureSheetManager.update_textures
      if (app_initialized)
        forEach (child in update_list.copy_from(components))
          if (child.active)
            local var view = child.(View)
            #view.push_transform
            #try
              view.draw
            #catch (Error err)
              #trace( err.to_String )
            #endTry
            #view.pop_transform
          endIf
        endForEach
      endIf

      # draw trace messages
      try
        if (trace_messages.count > 0)
          clipping_region = Box( display_size )

          local Int32 y = 0
          SystemFont  #prep singleton
          forEach (mesg in trace_messages)
            SystemFont.draw( mesg, Vector2(0,y) )
            y += SystemFont.height
          endForEach

          # 6 seconds until first message disappears
          # and afterwards another disappears every second
          if (time_ms - last_trace_activity_ms > 6000)
            trace_messages.remove_first
            last_trace_activity_ms = time_ms - 5000
          endIf
        endIf
      catch (Error err)
        log( err.to_String )
      endTry

    method on( MouseEvent e ):
      local var mouse_position = e.position
      forEach (child in components)
        if (child.active)
          local View view = child.(View)
          local var pos = mouse_position.transformed(view.screen_to_view)
          view.mouse_position = pos
          view.on( MouseEvent(e.type,e.mouse_id,pos,e.button) )
        endIf
      endForEach

    method on( KeyEvent e ):
      forEach (child in components)
        if (child.active) child.(View).on( e )
      endForEach

    method on( JoystickEvent e ):
      forEach (child in components)
        if (child.active) child.(View).on( e )
      endForEach

    method on( AccelerationEvent e ):
      local Vector2 xy( e.x, e.y )
      forEach (child in components)
        if (child.active)
          local View view = child.(View)
          local var a = xy.rotated(-view.angle)
          view.on( AccelerationEvent(e.controller_id,a.x,a.y,e.z) )
        endIf
      endForEach

    method on( SystemEvent e ):
      forEach (child in components)
        if (child.active) child.(View).on( e )
      endForEach

endClass

class Component : GenericImage, InputListener
  PROPERTIES
    parent   : Panel
    position : Vector2
    screen_to_view : Transform
    view_to_screen : Transform
    active=true : Logical
    must_recalculate_transforms : Logical

  METHODS
    method init( parent ):
      parent.components.add( this )

    method must_recalculate_transforms( Logical setting ):
      &must_recalculate_transforms = setting

    method push_transform:
      &must_recalculate_transforms = true
      if (&must_recalculate_transforms)
        recalculate_transforms
        &must_recalculate_transforms = false
      else
        Transform.camera.add( view_to_screen )
      endIf

    method recalculate_transforms:
      Transform.camera.add( Transform(handle,angle,scale,position) )
      view_to_screen = Transform.local_to_screen
      screen_to_view = Transform.screen_to_local

    method pop_transform:
      Transform.camera.discard_last

    method handle( handle ):
      # Handle property-set.
      &must_recalculate_transforms = true

    method handle( Handle h ):
      # Handle property-set.
      prior.handle(h)
      &must_recalculate_transforms = true

    method size( size ):
      &must_recalculate_transforms = true

    method angle( angle ):
      # Angle property-set.
      &must_recalculate_transforms = true

    method angle( Degrees deg ):
      # Angle property-set.
      &angle = to_Radians(deg)
      &must_recalculate_transforms = true

    method scale( scale ):
      # Scale property-set.
      &must_recalculate_transforms = true

    method scale( Real64 uniform_scale ):
      # Scale property-set.
      &scale = Vector2(uniform_scale,uniform_scale)
      &must_recalculate_transforms = true

    method position( position ):
      &must_recalculate_transforms = true

    method draw( position ):
      draw

    method draw-wrapper:
      push_transform
      try
        draw
      catch (Error err)
        trace( err.to_String )
      endTry
      pop_transform

    method draw:

    method update:

    method fill( Color c ):
      # Fill's this component with the given color.
      bounding_box.fill(c)

    method bring_to_front:
      # Brings this Component, Panel, View, or Screen in front
      # of its siblings.
      parent.components.remove( this )
      parent.components.add( this )
endClass

class Panel : Component
  PROPERTIES
    components(0) : Component[]

  METHODS
    method recalculate_transforms:
      prior.recalculate_transforms
      forEach (c in components) c.&must_recalculate_transforms = true

    method draw:
      forEach (c in components) c.draw
endClass

class ImageComponent : Component
  # Simple wrapper that displays an image as a component.
  PROPERTIES
    image : GenericImage

  METHODS
    method init( Panel _parent, image ):
      prior.init( _parent )

    method draw:
      image.draw(0,0)
endClass

class View : Panel, InputDispatcher
  PROPERTIES
    mouse_position : Vector2
      # The current mouse position relative to this view.

  METHODS
endClass

class Screen : View
  METHODS
    method init_object:
      GUIManager.components.add( this )
      parent = GUIManager
      orient_up

    method init:

    method orient_up.Screen:
      position = display_size / 2
      size = display_size
      handle = Handle.center
      angle = Degrees(0)
      IPhone.orient(0)
      return this

    method orient_down.Screen:
      position = display_size / 2
      size = display_size
      handle = Handle.center
      angle = Degrees(180)
      IPhone.orient(2)
      return this

    method orient_right.Screen:
      position = display_size / 2
      size = display_size.swapped
      handle = Handle.center
      angle = Degrees(90)
      IPhone.orient(1)
      return this

    method orient_left.Screen:
      position = display_size / 2
      size = display_size.swapped
      handle = Handle.center
      angle = Degrees(270)
      IPhone.orient(3)
      return this
endClass

deferred singleton class SystemMonitor : Screen
  PROPERTIES
    show_texture_sheets_setting : Logical
      # Set this debugging option to true to have the GUIManager 
      # display the texture sheets in use by the program.  The sheets
      # are 1024x1024 on the IPhone and 512x512 on other systems.
      # They are scaled down to fit the display screen.

    show_memory_usage_setting : Logical


  METHODS
    method show_texture_sheets( Logical setting ):
      show_texture_sheets_setting = setting

    method show_memory_usage( Logical setting ):
      show_memory_usage_setting = setting

    method show_all:
      show_texture_sheets_setting = true
      show_memory_usage_setting = true

    method hide_all:
      show_texture_sheets_setting = false
      show_memory_usage_setting = false

    method log_drawing( Logical setting ): native

    method update:
      bring_to_front

    method draw:
      local Vector2 offset( 0, SystemFont.height )

      if (show_texture_sheets_setting)
        local var index = (time_ms / 2000) % TextureSheetManager.sheets.count
        local var sheet = TextureSheetManager.sheets[index]
        local var img = sheet.image
        local var s = (display_size / TextureSheetManager.texture_sheet_size).min
        if (s > 1.0) s = 1.0
        img.scale = s
        img.bounding_box.fill(Color.blue)
        img.draw(0,0)
        sheet.draw(s)
        SystemFont.draw( "TEXTURE SHEET $/$" (index+1,TextureSheetManager.sheets.count), offset*0 )
      endIf

      if (show_memory_usage_setting)
        local var usage = System.memory_usage
        SystemFont.draw( "MEMORY USAGE", offset*2 )
        SystemFont.draw( usage.to_String, offset*3 )
      endIf

endClass

singleton class PixelFormat
  # Specifies one of several possible pixel formats for an image
  # to be stored in as it's loaded.  This is not related to the original 
  # file format, but rather suggests how the image may be stored once 
  # it's loaded into memory.  Native layer implementations may ignore
  # a PixelFormat hint.
  #
  # The following pixel formats are available.
  #
  #   rgb32
  #     Suggests a 32-bit ARGB or RGB format.
  #   
  #   rgb16
  #     Suggests a 16-bit format such as (A1,R5,G5,B5) or
  #     (R5,G6,B5) - the exact format chosen depends on the image
  #     data and available hardware support.
  #
  #   indexed
  #     Suggests an indexed color (palettized) format such as
  #     2-bit, 4-bit, or 8-bit - the exact format chosen depends on 
  #     the image data and available hardware support.
  PROPERTIES
    rgb32(1), rgb16(2), indexed(4) : Int32
endClass


class Texture : RequiresCleanup
  # Wrapper class for a native-layer texture.  Most developers will want to use
  # class Image instead of working with class Texture directly.
  PROPERTIES
    native_resource : NativeResource
    image_size   : readOnly Vector2
    texture_size : readOnly Vector2

  METHODS
    method init( Bitmap src_bitmap, Int32 pixel_format=PixelFormat.rgb32 ): native
      # Creates a texture from the given software bitmap.
      #
      # 'pixel_format' is a pixel format suggestion for how the loaded image
      # should be stored in video memory.  Choices are "rgb32", "rgb16",
      # and "indexed".

    method init( Vector2 size ): native
      # Creates a texture of the given size that can be rendered to.  See OffscreenBuffer.

    method clean_up:
      # Internal use.  Calls release().
      release

    method release: native
      # Releases the video memory used by the associated image in the
      # hardware layer.  May be called manually, but is also 
      # automatically called when this object has no more references.

    method set( Bitmap src ): native
      # Resets this texture to contain data from the specified bitmap.
      # If this texture is already the same size as the bitmap then
      # the video memory is rewritten rather than being reallocated.
      #
      # Note: the resulting texture is always in rgb32 format.

    method hash_code.Int32:
      return native_resource.index

    method draw( Corners uv, Vector2 size, Color color, Render render_flags=Render.default, Blend blend_fn=Blend.normal ): native 
      # Internal use.  Draws a subset of this texture defined by texture
      # positions 'uv' to the screen from (0,0) to 'size' in local space.
      # In general an existing transform will cause the texture to be
      # drawn at various positions and angles on-screen.  'color' is the
      # color multiplier for all vertices.

    method draw( Corners uv, Vector2 size, Color color, Render render_flags=Render.default, 
        Blend blend_fn=Blend.normal, Texture alpha_texture, Corners alpha_uv ): native 

    method draw( Corners uv, Quad vertices, ColorGradient colors, Render render_flags=Render.default, Blend blend_fn=Blend.normal ): native 
      # Internal use.  Draws a subset of this texture defined by texture
      # positions 'uv' and color values 'colors' to the screen at the given 
      # vertex positions (which are multiplied by the current transform).

    method draw( Vector2 uv1, Vector2 uv2, Vector2 uv3, Triangle vertices, Color color1, Color color2, Color color3, Render render_flags=Render.default, 
        Blend blend_fn=Blend.normal ): native 
      # Internal use.  Draws a subset of this texture defined by texture
      # positions 'uv' the given color values to the screen at the given 
      # vertex positions (which are multiplied by the current transform).
endClass


requisite class Image : GenericImage, RequiresCleanup
  # Wrapper class for a hardware-accelerated image.  Image objects
  # don't contain the actual image data, but instead store an index 
  # that the native layer uses to identify images.
  CLASS_PROPERTIES
    use_texture_sheets=true : Logical

  PROPERTIES
    texture : Texture
      # The index used to identify the associated image to the native layer.

    uv : Corners
      # The texture (u,v) coordinates, each [0..1].

    texture_sheet_corner : Vector2
      # Typically used to keep track of where this image's texture resides 
      # on its texture sheet.

    alpha_mask : Image
      # Another image to take alpha values from when this image is drawn.
      # If "null" (default), both alpha and color values are taken from
      # this image.

    manager : TextureSheetManager
      # Internal use.  If non-null, is the object that manages the texture data 
      # for this image.

  METHODS
    method init( String filename, String texture_sheet_name="", 
        Int32 pixel_format=PixelFormat.rgb32 ):
      # Creates an image from the given png or jpeg file.  Some platforms may
      # support additional formats.
      #
      # The following variations of 'filename' are checked:
      #
      #   filename
      #   filename.ext  (.ext = [.png|.jpg|.jpeg])
      #   data/filename
      #   data/filename.ext
      #
      # 'pixel_format' is a pixel format suggestion for how the loaded image
      # should be stored in video memory.  Choices are "rgb32", "rgb16",
      # and "indexed".
      #
      # Note: if a PNG isn't loading correctly, try running Ken Silverman's 
      # PNGOUT program on it.  This is a good idea anyways as PNGOUT compression
      # is generally better and decompresses faster than normal PNG compression.
      if (texture_sheet_name? and use_texture_sheets)
        local var src_image = TextureSheetManager[filename,texture_sheet_name]
        texture = src_image.texture
        size = src_image.size
        uv = src_image.uv
        manager = src_image.manager
        texture_sheet_corner = uv.top_left * texture.texture_size
        src_image.manager = null
      else
        init( Bitmap(filename), null, pixel_format )
      endIf

    method init( Bitmap src_bitmap, String texture_sheet_name="", 
        Int32 pixel_format=PixelFormat.rgb32 ):
      # Creates an image from the given software bitmap.
      #
      # 'pixel_format' is a pixel format suggestion for how the loaded image
      # should be stored in video memory.  Choices are "rgb32", "rgb16",
      # and "indexed".
      if (texture_sheet_name? and use_texture_sheets)
        local var src_image = TextureSheetManager[src_bitmap,texture_sheet_name]
        texture = src_image.texture
        size = src_image.size
        uv = src_image.uv
        manager = src_image.manager
        texture_sheet_corner = uv.top_left * texture.texture_size
        src_image.manager = null
      else
        texture = Texture( src_bitmap, pixel_format )
        size = texture.image_size
        uv = Corners( Vector2(0,0), size / texture.texture_size )
      endIf

    method init( Image existing, Int32 x, Int32 y, Int32 w, Int32 h ):
      # Creates an image as a subset of an existing image.  The actual
      # texture is shared with the original image; only a minimal 
      # amount of additional memory is required.
      #
      # Parameters:
      #   existing
      #     An existing image to pick a subset of.
      #
      #   x,y
      #     The top-left corner of the image subset relative to the
      #     top-left corner of the existing image.
      #
      #   w,h
      #     The width and height of the image subset.
      init( existing, Vector2(x,y), Vector2(w,h) )

    method init( Image existing, Vector2 top_left, size ):
      # Creates an image as a subset of an existing image.  The actual
      # texture is shared with the original image; only a minimal 
      # amount of additional memory is required.
      #
      # Parameters:
      #   existing
      #     An existing image to pick a subset of.
      #
      #   top_left
      #     The top-left corner of the image subset relative to the
      #     top-left corner of the existing image.
      #
      #   size
      #     The width and height of the image subset.
      texture = existing.texture
      local var uv_size = existing.uv.size
      local var existing_uv1 = existing.uv.top_left;
      local var existing_size = existing.size
      local var bottom_right = top_left + size
      uv = Corners( (top_left / existing_size) * uv_size + existing_uv1,
                    ((bottom_right) / existing_size) * uv_size + existing_uv1 )
      texture_sheet_corner = uv.top_left * texture.texture_size
      if (existing.manager?)
        manager = existing.manager
        manager.retain( this )
      endIf

    method init( Image existing, Box box ):
      # Creates an image as a subset of an existing image.  The actual
      # texture is shared with the original image; only a minimal 
      # amount of additional memory is required.
      #
      # Parameters:
      #   existing
      #     An existing image to pick a subset of.
      #
      #   box
      #     The rectangular region of the desired subset.
      init( existing, box.position, box.size )

    method clean_up:
      # Internal use.  Calls release().
      release

    method release:
      if (manager?) manager.release(this)

    method hash_code.Int32:
      return texture.native_resource.index

    method alpha_mask( Image new_alpha_mask ):
      if (new_alpha_mask? and new_alpha_mask.texture is this.texture)
        throw InvalidOperandError( "new_alpha_mask: an image's alpha_mask cannot use its same texture - make sure they're not both on the same texture sheet by loading one of them as Image(filename,false)" )
      endIf
      &alpha_mask = new_alpha_mask

    method draw( Vector2 v ):
      local var original_transform_count = Transform.object.count
      if (hflip or vflip)
        local var half_size = size / 2
        Transform.object.add( Transform.translate(-half_size) )
        if (hflip)
          if (vflip) Transform.object.add( Transform(-1,0,0,0,-1,0) )
          else       Transform.object.add( Transform(-1,0,0,0, 1,0) )
        else
          Transform.object.add( Transform( 1,0,0,0,-1,0) )
        endIf
        Transform.object.add( Transform(handle-half_size,angle,scale,v) )
      else
        Transform.object.add( Transform(handle,angle,scale,v) )
      endIf

      if (alpha_mask?)
        texture.draw( uv, size, color, render_flags, blend, alpha_mask.texture, alpha_mask.uv )
      else
        texture.draw( uv, size, color, render_flags, blend )
      endIf
      Transform.object.discard(original_transform_count)

    method draw( Box box ):
      # Draws this image at the specified rectangular coordinates.
      draw( box, ColorGradient(color) )

    method draw( Box box, ColorGradient colors ):
      # Draws this image at the specified rectangular coordinates with
      # the given corner colors.
      if (hflip)
        if (vflip)
          draw( Quad(Box(box.bottom_right,box.top_left)), ColorGradient(color) )
        else
        endIf
      elseIf (vflip)
      else
        draw( Quad(box), ColorGradient(color) )
      endIf

    method draw( Quad q ):
      # Draws this image at the specified quadrangular coordinates.
      draw( q, ColorGradient(color) )

    method draw( Quad q, ColorGradient colors ):
      # Draws this image at the specified quadrangular coordinates with
      # the given corner colors.
      texture.draw( uv, q, colors, render_flags, blend )

    method crop( Real64 pixels_to_contract ):
      # Contracts the edge UV texture coordinates by 
      # 'pixels_to_contract' along each edge and reduces the
      # 'size' of this image by "2*pixels_to_contract" in each
      # dimension.
      #
      # The existing 'size' is used to calculate how much the
      # UV coordinates should be adjusted by.
      #
      # Does not change the 'handle', which may need to be reset.
      local Box box = Box(uv)
      box = box.cropped( pixels_to_contract * box.size / this.size )
      uv = Corners( box )
      size -= pixels_to_contract * 2

    method crop( Box bounds ):
      # Adjusts the UV coordinates and size of this image to match
      # the pixel dimensions of the given 'bounds' box.
      #
      # Does not change the 'handle', which may need to be reset.
      local Box uv_box = Box(uv)
      uv_box = uv_box.intersection( bounds * (uv_box.size / this.size) )
      uv = Corners( uv_box )
      size = bounds.size

    method split_into_tiles( Int32 tiles_wide, Int32 tiles_high ).Image[]:
      # Splits this Image into a list of separate Image tiles.
      local Image[] tiles( tiles_wide * tiles_high )

      local Vector2 tile_size( size.x / tiles_wide, size.y / tiles_high )

      forEach (j in 0..<tiles_high)
        forEach (i in 0..<tiles_wide)
          tiles.add( Image( this, Vector2(i,j)*tile_size, tile_size ) )
        endForEach
      endForEach

      return tiles
endClass

class OffscreenBuffer : Image
  # Creates an image that may be drawn as normal or drawn to by calling
  # "Application.set_draw_target(buffer)", where "buffer" is this buffer.

  METHODS
    method init( size ): 
      # Creates an offscreen buffer of the given size.  Note that the size
      # will internally be adjusted to be a power of 2 in each dimension.
      texture = Texture( size )
      uv = Corners( Vector2(0,0), size / texture.texture_size )
      clear

    method init( Int32 w, Int32 h ):
      # Creates an offscreen buffer of the given size.  Note that the size
      # will internally be adjusted to be a power of 2 in each dimension.
      init( Vector2(w,h) )

    method clear( Color c=Color(0x00000000) ): native
endClass

class CompositeImage : Panel, RequiresCleanup
  # A composite image is designed for loading and displaying
  # large splash screens and other background graphics.  Upon
  # initialization it loads a given image and then breaks it
  # up into 256x256-pixel chunks - which are then redrawn pieced
  # together as a whole.
  METHODS
    method init( String filename, String sheet_name="" ):
      # Initializes this CompositeImage to draw the given image.
      init( Bitmap(filename), sheet_name )

    method init( Bitmap bmp, String sheet_name="" ):
      # Initializes this CompositeImage to draw the given bitmap.
      size = bmp.size

      # A 1 pixel border on all edges will be added when placed on the
      # texture sheet - compensating for this allows us to pack more
      # textures on in general.
      local var chunk_width  = 254
      local var chunk_height = 254

      local Vector2 chunk_size(chunk_width,chunk_height)
      forEach (y in 0..<size.y step chunk_height)
        forEach (x in 0..<size.x step chunk_width)
          add( Image(Bitmap(bmp, Vector2(x,y), chunk_size), sheet_name), Vector2(x,y) )
        endForEach
      endForEach
    
    #method init:
      # Default initializer.

    method init( size ):
      # Initializes this object to an empty image of the given size.
      # Additional image subparts may be added with the add() method.
    
    #method size( Vector2 new_size ):
      # Size property-set.
      #prior.size( new_size )
      #local Vector2 k = new_size / size
      #forEach (img in parts) img.size *= k

    method add( GenericImage img, Vector2 offset ):
      # Adds 'img' to this composite image - 'img' may be an Image or
      # a CompositeImage object.  It will be drawn with its handle 
      # at 'offset' relative to the top-left corner of this image.
      img.handle -= offset
      components.add( ImageComponent(this,img) )

    method draw( Vector2 pos ):
      # draw() method.
      position = pos
      draw

    #method draw-wrapper:
      #if (&must_recalculate_transforms)
        #recalculate_transforms
        #&must_recalculate_transforms = false
      #endIf

    method draw:
      forEach (c in components) 
        c.render_flags = render_flags
        c.color = color
        c.blend = blend
        #img.scale = scale
        #img.draw( handle * img.scale )
        c.draw(0,0)
      endForEach
      #Box(position,size).draw(Color.green)

    method release:
      # Calls release() on each of this CompositeImage object's 
      # constituent parts.
      forEach (c in components) c.release
      components.clear

    #method recalculate_transforms:
      #prior.recalculate_transforms
      #Transform.object.add( Transform(handle,angle,scale,position) )
      #view_to_screen = Transform.local_to_screen
      #screen_to_view = Transform.screen_to_local
      #forEach (c in components) c.must_recalculate_transforms = true

    method clean_up:
      release
endClass

#=====================================================================
# TextureSheetManager
# TextureSheet
#=====================================================================
singleton class TextureSheetManager
  PROPERTIES
    texture_sheet_size : Vector2
    sheets()           : TextureSheet[]
    has_freed_regions  : Logical

  METHODS
    method init:
      #if (System.os == "iphone")
      texture_sheet_size = Vector2(1024,1024)
      #else
        #texture_sheet_size = Vector2(512,512)
      #endIf

    method get( String filename, String sheet_name ).Image:
      free_unused_regions
      local Bitmap bmp( filename )
      local var old_texture_sheet_policy = Image.use_texture_sheets
      Image.use_texture_sheets = false
      local var img = add( bmp, sheet_name )
      Image.use_texture_sheets = true
      return img

    method get( Bitmap src_bitmap, String sheet_name ).Image:
      free_unused_regions
      local var old_texture_sheet_policy = Image.use_texture_sheets
      Image.use_texture_sheets = false
      local var img = add( src_bitmap, sheet_name )
      Image.use_texture_sheets = true
      return img

    private method add( Bitmap bmp, String sheet_name ).Image:
      local var size = bmp.size + 2
      if (size.x > texture_sheet_size.x or ...
          size.y > texture_sheet_size.y)
        return Image(bmp)
      endIf

      free_unused_regions

      local var region = allocate_in_existing( size, sheet_name )
      if (not region?)
        local var sheet = TextureSheet( texture_sheet_size, sheet_name )
        sheets.add( sheet )
        region = sheet.allocate( size )
      endIf

      local Bitmap padded_bmp( size )
      bmp.draw_column_to( 0, padded_bmp, 0, 1 )
      bmp.draw_column_to(-1, padded_bmp,-1, 1 )
      bmp.draw_row_to( 0, padded_bmp, 1, 0 )
      bmp.draw_row_to(-1, padded_bmp, 1,-1 )
      padded_bmp.plot( 0, 0, bmp.get( 0, 0) )
      padded_bmp.plot(-1, 0, bmp.get(-1, 0) )
      padded_bmp.plot( 0,-1, bmp.get( 0,-1) )
      padded_bmp.plot(-1,-1, bmp.get(-1,-1) )
      bmp.draw_to( padded_bmp, 1, 1, false )

      set_draw_target(region.sheet.image,false)
      Image(padded_bmp).draw( region.bounds.top_left )
      set_draw_target(null)

      local Image result( region.sheet.image, Box(region.bounds.top_left,size) )
      result.crop(1)
      result.manager = this
      return result

    method free_unused_regions:
      if (not has_freed_regions) return
      has_freed_regions = false

      forEach (sheet in sheets)
        local var released_any = false
        forEach (a in sheet.allocations)
          if (a.reference_count == 0)
            sheet.release( a )
            released_any = true
            removeCurrent a
          endIf
        endForEach
        if (released_any?) sheet.merge_adjacent_strips
      endForEach

    method allocate_in_existing( Vector2 size, String sheet_name ).TextureSheetAllocation:
      if (sheet_name.count?)
        forEach (sheet in sheets)
          if (sheet.name == sheet_name)
            local var region = sheet.allocate( size )
            if (region?) return region
          endIf
        endForEach
      else
        # any sheet is fine
        forEach (sheet in sheets)
          local var region = sheet.allocate( size )
          if (region?) return region
        endForEach
      endIf

      return null

    method find_sheet( Texture tx ).TextureSheet:
      forEach (s in sheets) 
        if (s.image.texture is tx) return s
      endForEach
      throw Error( "[Internal] TextureSheetManager retain() or release() called with unmanaged texture!" )

    method retain( Image img ):
      local var sheet = find_sheet( img.texture )
      sheet.retain( img.texture_sheet_corner )

    method release( Image img ):
      # Internal use.  This method is called asynchronously from 
      # Image::clean_up during garbage collection.
      img.manager = null
      local var sheet = find_sheet( img.texture )
      if (sheet.release(img.texture_sheet_corner)) has_freed_regions = true

endClass


class TextureSheet
  PROPERTIES
    image   : OffscreenBuffer

    name="" : String

    size    : Vector2

    table   : TextureSheetCell
      # The top-left cell of the table.  Always exists.  Starts as one cell.

    candidates() : TextureSheetCell[]
      # Each candidates is flagged when we consider it to avoid considering
      # subsets of existing candidates; this list is used to clear the flags
      # when a candidate is chosen.

    allocations() : TextureSheetAllocation[]

  METHODS
    method init( size, name ):
      table = TextureSheetCell(Box(size))
      table.has_gap_above = false
      image = OffscreenBuffer(size)

    method allocate( Vector2 pixel_size ).TextureSheetAllocation:
      local TextureSheetCell match
      local TextureSheetCell area_match
      local TextureSheetCell width_match
      local TextureSheetCell height_match
      local Int32  min_area, min_w, min_h
      local var allow_gaps = false

      pixel_size = Vector2( (pixel_size.x.(Int32)+15) & !15, (pixel_size.y.(Int32)+15) & !15 )
      candidates.clear
      block
        forEach (1..2)
          forEach (row in table.down)
            forEach (cell in row.across)
              if (cell.allocation_id == 0 and (not cell.is_candidate) and cell.can_fit(pixel_size,allow_gaps))
                candidates.add(cell)
                cell.mark_candidate(true,pixel_size.x,100000)
                cell.mark_candidate(true,100000,pixel_size.y)
                local var w = cell.free_width
                local var h = cell.free_height
                local var area = w * h
                if (not area_match?)
                  area_match = cell
                  width_match = cell
                  height_match = cell
                  min_area = area
                  min_w = w
                  min_h = h
                else
                  if (w == pixel_size.x)
                    if (h == pixel_size.y)
                      # perfect match
                      match = cell
                      escapeBlock
                    else
                      if (h < min_h) min_h = h; width_match = cell
                    endIf
                  elseIf (h == pixel_size.y)
                    if (w < min_w) min_w = w; height_match = cell
                  else
                    if (area < min_area) min_area = area; area_match = cell
                  endIf
                endIf
              endIf
            endForEach
          endForEach
          if (candidates.count?) escapeBlock
          else allow_gaps = true
        endForEach
      endBlock

      # no candidates = no matches
      if (candidates.count == 0) return null

      # clear candidate flags
      forEach (candidate in candidates) 
        candidate.mark_candidate(false,pixel_size.x,100000)
        candidate.mark_candidate(false,100000,pixel_size.y)
      endForEach

      # if no perfect match in both dimensions, look for the best-possible
      # match in width, then height, then area.
      if (not match?)
        if (width_match?) match = width_match
        elseIf (height_match?) match = height_match
        else match = area_match
      endIf

      # split axes on edges of allocation
      split_horizontal( match.bounds.x1 + pixel_size.x )
      split_vertical( match.bounds.y1 + pixel_size.y )
      # mark each cell in allocation as in_use
      local var h = pixel_size.y
      local var id = TextureSheetCell.next_allocation_id
      TextureSheetCell.next_allocation_id++
      forEach (row in match.down)
        local var w = pixel_size.x
        forEach (cell in row.across)
          cell.allocation_id = id
          w -= cell.bounds.width
          if (cell.south_link?) cell.south_link.has_gap_above = false
          if (w == 0.0) escapeForEach
        endForEach
        h -= row.bounds.height
        if (h == 0.0) escapeForEach
      endForEach

      local TextureSheetAllocation allocation( this, Box(match.bounds.position,pixel_size), match )
      allocations.add( allocation )
      return allocation

    method split_horizontal( Real64 x ):
      if (x == 0.0) return
      forEach (cell in table.across)
        local var x2 = cell.bounds.x2
        if (x2 >= x)
          if (x2 > x) 
            cell.split_horizontal(x)
          endIf
          return
        endIf
      endForEach

    method split_vertical( Real64 y ):
      if (y == 0.0) return
      forEach (cell in table.down)
        local var y2 = cell.bounds.y2
        if (y2 >= y)
          if (y2 > y) cell.split_vertical(y)
          return
        endIf
      endForEach

    method find_allocation( Vector2 corner ).TextureSheetAllocation:
      forEach (a in allocations)
        if (a.bounds.contains(corner)) return a
      endForEach
      throw InvalidOperandError("corner:" + corner )

    method retain( Vector2 corner ):
      find_allocation(corner).retain
      
    method release( Vector2 corner ).Logical:
      local var allocation = find_allocation( corner )
      return allocation.release

    method release( TextureSheetAllocation allocation ):
      local TextureSheetCell corner = allocation.corner

      local var h = allocation.bounds.height
      forEach (row in corner.down)
        local var w = allocation.bounds.width
        forEach (cell in row.across)
          cell.allocation_id = 0
          w -= cell.bounds.width
          if (cell.south_link?) cell.south_link.has_gap_above = true
          if (w == 0.0) escapeForEach
        endForEach
        h -= row.bounds.height
        if (h == 0.0) escapeForEach
      endForEach

    method merge_adjacent_strips:
      merge_rows
      merge_columns

    method merge_rows:
      forEach (row in table.down)
        while (row.can_merge_down) 
          row.merge_down
        endWhile
      endForEach

    method merge_columns:
      forEach (column in table.across)
        while (column.can_merge_right) 
          column.merge_right
        endWhile
      endForEach

    method draw( Real64 scale ):
      forEach (row in table.down) 
        row.draw(scale)
      endForEach
      
endClass


class TextureSheetAllocation
  PROPERTIES
    sheet  : TextureSheet
    bounds : Box
    corner : TextureSheetCell
    reference_count=1 : Int32

  METHODS
    method init( sheet, bounds, corner ):

    method retain:
      reference_count++

    method release.Logical:
      reference_count--
      return (reference_count == 0)
endClass


class TextureSheetCell
  CLASS_PROPERTIES
    next_allocation_id=1 : Int32

  PROPERTIES
    bounds  : Box
    #north_link, west_link : TextureSheetCell
    east_link, south_link : TextureSheetCell
    allocation_id : Int32
    is_candidate : Logical
    has_gap_above=true : Logical

  METHODS
    method init( bounds ):

    method mark_candidate( Logical setting, Real64 width, Real64 height ):
      forEach (row in this.down)
        if (row.allocation_id?) return
        local var w = width
        forEach (cell in row.across)
          if (cell.allocation_id?) escapeForEach
          cell.is_candidate = setting
          w -= cell.bounds.width
          if (w <= 0) escapeForEach
        endForEach
        height -= row.bounds.height
        if (height <= 0) return
      endForEach

    method across.TextureSheetCellIterator:
      return TextureSheetCellIterator( this, true )

    method down.TextureSheetCellIterator:
      return TextureSheetCellIterator( this, false )

    method can_fit( Vector2 size, Logical allow_gaps ).Logical:
      if (allocation_id?) return false

      local var w = 0.0
      local var h = bounds.height
      forEach (cell in this.across)
        if (cell.allocation_id? or (cell.has_gap_above and not allow_gaps)) return false
        w += cell.bounds.width
        if (cell.free_height < size.y) return false
        if (w >= size.x) return true
      endForEach

      return false

    method free_width.Real64:
      if (allocation_id?) return 0.0
      if (east_link?) return east_link.free_width + bounds.width
      return bounds.width

    method free_height.Real64:
      if (allocation_id?) return 0.0
      if (south_link?) return south_link.free_height + bounds.height
      return bounds.height

    method split_horizontal( Real64 x ):
      if (south_link?) 
        south_link.split_horizontal(x)
      endIf

      local var this_width = x - bounds.x1
      local var next_width = bounds.width - this_width
      local TextureSheetCell next( Box(x,bounds.y1,next_width,bounds.height) )
      next.allocation_id = allocation_id
      next.has_gap_above = this.has_gap_above
      bounds = Box( bounds.position, Vector2(this_width,bounds.height) )

      next.east_link = this.east_link
      this.east_link = next
      if (south_link?) east_link.south_link = south_link.east_link

    method split_vertical( Real64 y ):
      if (east_link?) 
        east_link.split_vertical(y)
      endIf

      local var this_height = y - bounds.y1
      local var next_height = bounds.height - this_height
      local TextureSheetCell next( Box(bounds.x1,y,bounds.width,next_height) )
      next.allocation_id = allocation_id
      bounds = Box( bounds.position, Vector2(bounds.width,this_height) )

      next.south_link = this.south_link
      this.south_link = next
      if (east_link?) south_link.east_link = east_link.south_link

    method can_merge_down.Logical:
      if (not south_link? or (allocation_id != south_link.allocation_id)) return false
      if (east_link?) return east_link.can_merge_down
      else return true

    method merge_down:
      if (east_link?) east_link.merge_down
      bounds = bounds.enclosing(south_link.bounds)
      south_link .= south_link
      #if (south_link?) south_link.north_link = this

    method can_merge_right.Logical:
      if (not east_link? or (allocation_id != east_link.allocation_id)) return false
      if (south_link?) return south_link.can_merge_right
      else return true

    method merge_right:
      if (south_link?) south_link.merge_right
      bounds = bounds.enclosing(east_link.bounds)
      east_link .= east_link

    method merge_east:
      if (south_link?) south_link.merge_east
      bounds = bounds.enclosing(east_link.bounds)
      east_link = east_link.east_link

    method draw( Real64 scale ):
      if (allocation_id == 0) 
        (bounds * scale).fill( Color.gray )
        (bounds * scale).draw( Color.black )
      endIf
      if (east_link?) east_link.draw(scale)
endClass


class TextureSheetCellIterator : Reader<<TextureSheetCell>>
  PROPERTIES
    cur : TextureSheetCell
    traverse_horizontal : Logical

  METHODS
    method init( cur, traverse_horizontal ):

    method has_another.Logical:
      return (cur?)

    method peek.TextureSheetCell:
      return cur

    method read.TextureSheetCell:
      local var result = cur
      if (traverse_horizontal) cur .= east_link
      else cur .= south_link
      return result
    
endClass


#=====================================================================
# ResourceGroup
# ResourceManager
#=====================================================================
underlying aspect ResourceGroup
  PROPERTIES
    count     : Int32
    index     : Int32
    is_loaded : Logical

  METHODS
    method init_object:
      count = runtime_num_properties - 3

    method load_next.Logical: abstract

    method unload: abstract

    method num_remaining.Int32:
      return (count - index)

    method load_next-wrapper.Logical:
      index++
      local var success = load_next
      is_loaded = not success
      return success

    method unload-wrapper:
      unload
      is_loaded = false
      index = 0
endAspect

singleton class ResourceManager
  PROPERTIES
    progress=1.0    : Real64
    used()          : ResourceGroup[]
    unused()        : ResourceGroup[]
    num_loaded      : Int32
    num_requested   : Int32

  METHODS
    method load( ResourceGroup group ):
      if (unused.contains(group)) unused.remove(group)

      if (not used.contains(group))
        if (progress == 1.0)
          num_loaded = 0
          num_requested = 0
        endIf

        used.add(group)
        num_requested += group.num_remaining
      endIf

      # Always set progress to 0.0 to ensure that the resources_loaded
      # system event gets called.
      progress = 0.0

    method finish_loading:
      while (progress < 1.0) update

    method unload( ResourceGroup group ):
      if (used.contains(group))
        num_requested -= group.num_remaining
      endIf

      if (not unused.contains(group)) unused.add(group)

    method unload_all:
      while (used.count?) unload( used.remove_last )

    method load_data_file( String filename ).Char[]: native

    method load_gamestate( String filename ).Char[]: native
    method save_gamestate( String filename, Char[] data ): native

    method save_gamestate( String filename, Reader<<Char>> data ):
      save_gamestate( filename, data.to_List )


    method update:
      if (progress == 1.0) return

      # unload unused groups on first update
      if (unused.count?)
        forEach (group in unused) group.unload
        unused.clear
        System.force_garbage_collection(2)
      endIf

      forEach (group in used)
        if (group.is_loaded) nextIteration
        group.load_next
        num_loaded++
        progress = Real64(num_loaded) / num_requested
        if (progress >= 1.0) progress = 0.99
        return
      endForEach

      progress = 1.0
      num_loaded = 0
      num_requested = 0
      GUIManager.on( SystemEvent(resources_loaded) )

endClass

#=====================================================================
# ColorGradient
#=====================================================================
compound ColorGradient( Color top_left, Color top_right, Color bottom_right, Color bottom_left )
  # Convenience compound that stores the four corner colors of a color gradient.

singleton class ColorGradientManager
  METHODS
    method create_from( Int32 color ).ColorGradient:
      # Creates a color gradient with all four entries containing the same color (given as an 0xAARRGGBB).
      return ColorGradient( Color(color), Color(color), Color(color), Color(color) )

    method create_from( Int32 c1, Int32 c2, Int32 c3, Int32 c4 ).ColorGradient:
      # Creates a color gradient with the specified corner colors (given as 0xAARRGGBB integers).
      return ColorGradient( Color(c1), Color(c2), Color(c3), Color(c4) )

    method create_from( Color color ).ColorGradient:
      # Creates a color gradient with the specified color in all four corners.
      return ColorGradient( color, color, color, color )

endClass



#=====================================================================
# TileLayoutInfo
# 
# For use with the TileLayout class.
#=====================================================================
class TileLayoutInfo
  # Base class for all custom TileLayoutInfo variants.
  PROPERTIES
    index : Int32
      # The order in which this TileInfo was fit onto a sheet as set
      # by TileLayout::layout().  All the TileInfo objects on a 
      # specific sheet will have a contiguous sequence of index 
      # values.  This is set by TileLayout.layout().

    sheet_index : Int32
      # The sheet index (0+) this TileInfo was fit onto.

    rect : Box
      # The position and size of this tile on its sheet.

  METHODS
    method init( Vector2 _size ):
      rect = Box( _size )

    method size.Vector2:
      # Size property-get.
      return rect.size

    method position( Vector2 pos ):
      # Position property-get.
      rect = Box(pos,rect.size)
endClass

class LetterLayoutInfo : TileLayoutInfo
  # A customized TileLayoutInfo variant that can have up to three
  # types of user-defined data associated with each object.
  PROPERTIES
    ch : Char

  METHODS
    method init( Vector2 _size, ch ):
      prior.init(_size)
endClass


#=====================================================================
# TileLayout
#=====================================================================
class TileLayout<<TileLayoutInfoType>>
  # Packs a series of rectangles (usually taken from images) into 
  # a number of logical sheets of a specified size.
  #
  # Used by the font loading system in particular.
  PROPERTIES
    sheet_size : Vector2

    # About: The next index to assign to a image as it's laid out.
    next_index : Int32

    tiles          : TileLayoutInfoType[]
    tiles_by_index : TileLayoutInfoType[]

  METHODS
    method init( sheet_size ):
      # Creates a layout that will create sheets of the given width
      # and height.  Pass 0 for either to have that dimension extend
      # indefinitely.
      if (sheet_size.x == 0) sheet_size = Vector2( 1000000, sheet_size.y )
      if (sheet_size.y == 0) sheet_size = Vector2( sheet_size.x, 1000000 )

    method layout( tiles, tiles_by_index=null ).Int32:
      # Lays out each given tile, stores its position info in
      # the TileInfo object, and returns the number of sheets created.
      #  
      # Parameters:
      #   tiles
      #     A list containing a TileInfo object for each box to 
      #     be laid out.  When this method is over, the index and 
      #     sheet_number/x/y of each TileInfo will be set.
      #
      #   by_index
      #     A reference to an existing but empty list to be filled by 
      #     a copy of the original TileInfo objects put into index 
      #     order.  This can make it easier to create lookup tables.
      #     All the tiles on a given sheet have a 
      #     monotonically-increasing set of indices.

      # create a duplicate set of tiles for sorting
      local TileLayoutInfoType[] work_list()

      if (tiles_by_index is null) tiles_by_index = ArrayOf<<TileLayoutInfoType>>[tiles.count]
      # add each tile to the work list
      forEach (tile in tiles)
        if (tile.size.x > sheet_size.x or tile.size.y > sheet_size.y)
          return 0  # won't fit
        endIf
        work_list.add( tile )
      endForEach

      # sort the tiles into order based on height first and width
      # second (largest area is at front of list)
      forEach (pass in 1..<work_list.count)
        local Logical is_sorted = true

        forEach (i in 0..<(work_list.count-pass))
          local var cur  = work_list[i]
          local var next = work_list[i+1]
          if (cur.size.y < next.size.y or
              (cur.size.y == next.size.y and cur.size.x < next.size.x))
            is_sorted = false
            work_list[i] = next
            work_list[i+1] = cur
          endIf
        endForEach

        if (is_sorted) escapeForEach
      endForEach

      # Reassign list of sorted tiles as "tiles" list.  Note that
      # caller's original list of tiles is unchanged.
      tiles = work_list

      # Perform the layout.
      next_index = 0
      local Int32 cur_sheet = 0
      while (tiles.count > 0) layout_sheet( cur_sheet ); cur_sheet++
      return cur_sheet

    
    method layout_sheet( Int32 sheet ):
      # Lays out as many tiles on the given logical sheet (0+) as it 
      # can before returning.  Each TileInfo object is removed from 
      # the list once processed.
      fill_area( sheet, 0, 0, sheet_size.x, sheet_size.y )


    method fill_area( Int32 sheet, Int32 x, Int32 y, Int32 width, 
        Int32 height ).Int32:
      # Recursively fills in the given area.  Returns the width of the
      # image found to fit the area.
      if (width <= 0 or height <= 0) return 0

      # Find the biggest tile that will fit in this area.
      local Int32 tile_index = 0
      forEach (i of tiles)
        local var tile = tiles[i]
        if (tile.size.x <= width and tile.size.y <= height)
          tile.index = next_index
          next_index++
          tile.sheet_index = sheet
          tile.position = Vector2(x,y)
          tiles_by_index.add( tiles.remove(i) )

          # recursively process the rest of the space

          # In the row underneath this row
          local Int32 lower_w = fill_area( sheet, x, y+tile.size.y, width, 
              height-tile.size.y )

          if (lower_w <= tile.size.x)
            return Int32( tile.size.x + fill_area( sheet, x+tile.size.x, y, 
                width-tile.size.x, height ) )

          else
            # Add on tiles to this row until its longer than the one
            # below me or I run out of room.
            local Int32 upper_w = tile.size.x
            local Int32 extent = 0
            while (upper_w < lower_w and upper_w+extent <= width)
              local Int32 add_w = fill_area( sheet, x+upper_w, y, extent, tile.size.y )
              if (add_w == 0) 
                extent++
                if (tiles.count == 0) return lower_w
              else
                upper_w += add_w
                extent -= add_w
              endIf
            endWhile

            # fill the entire area after the top and bottom row
            if (upper_w < lower_w) upper_w = lower_w
            return upper_w + fill_area( sheet, x+upper_w, y, width-upper_w, height )
          endIf
        endIf
      endForEach

      return 0
endClass

#====================================================================
# Font
#====================================================================
enum FontStyle : BitFlags<<FontStyle>>
  # Used to specify different font styles when loading.  The following
  # styles are available:
  #
  #   fixed_width
  #     Each character in a font strip is the same number of pixels 
  #     wide.
  #
  #   proportional
  #     Each character in a font strip can have a different pixel 
  #     width.
  #
  #   linear_filter
  #     Peforms linear filtering on each letter as it's drawn.
  #
  #   point_filter
  #     Draws nearest-neighbor pixels.  If this flag is omitted 
  #     then linear filtering is used.
  #
  #   snug
  #     Adjusts the logical widths of all characters by -1 pixel
  #     after loading; often appropriate for fonts with black 
  #     outlines. Without snug letters, two capital "M" characters 
  #     in a black-outline font might have two columns of black 
  #     pixels in-between them.  With snug letters there would only
  #     be one column.
  #
  # Example:
  #   high_score_font( "somefont.png", 
  #       FontStyle.fixed_width | FontStyle.snug ) : Font
  CATEGORIES
    fixed_width(1), proportional(2)
    linear_filter(4), point_filter(8)
    snug(16)

endEnum


class Font
  # Manages a bitmapped font.  A font loads png or jpeg images 
  # containing font strips, breaks up the letters, arranges them onto
  # square textures, and draws the images piece by piece as needed.
  # 
  # Fonts can be loaded as proportional or non-proportional.  All
  # letters in a font must have the same height (though parts of 
  # that area can be blank/transparent).  The drawing origin of every
  # character is the top-left corner.
  # 
  # The image width of a non-proportional font is divided by the
  # number of characters in it to determine the character width.
  # 
  # A proportional font has a single-pixel-high band of alternating 
  # colors in the topmost row.  The length of any contiguous patch 
  # of the same color determines the width of the character 
  # underneath.  The actual color used does not matter.
  # 
  # Since font strips tend to be images that are too long
  # for texture hardware to support, every font is automatically
  # broken up and laid out on square textures up to 256x256 in
  # size.  Any empty pixels around each letter are removed before 
  # laying out the letter on a texture.
  # 
  # Either point filtering or linear filtering can be selected
  # for a font.  If linear filtering is chosen, an extra outline
  # of padding is added around each letter before it is laid out
  # to avoid color bleeding.
  # 
  # Copy and paste the following letter strip in Photoshop or
  # another paint program to get started on a font strip.  Notice
  # the first character is a space; if you accidentally leave it 
  # out then all your letters will be one position off.
  # 
  #  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~

  PROPERTIES
    height                       : Int32
      # The original pixel height of each character in the font.

    color=Color(255,255,255,255) : Color
      # The multiplier for each pixel in this font as it's drawn.
      # The default color of Color(255,255,255,255) ensures that 
      # the font will appear "normal".  A color of 
      # Color(255,255,0) would not draw any of the blue channel, 
      # making a grey-scale letter appear to be tinted yellow.  A color
      # of Color(255,255,255,128) would draw the letters halfway
      # transparent.

    scale(1.0,1.0)   : Vector2
      # The size multiplier for rendering, (1.0,1.0) by default.
      # Setting "scale = Vector2(2.0,0.5)" would cause the font to
      # render at twice the width and half the height.

    characters       : HashTable<<Char,FontCharacter>>

  METHODS
    method init( String filename, FontStyle style=FontStyle.fixed_width,
        String mapping=String(' '..'~') ):
      # Intializes this font from characters in the given font strip.
      #
      # Parameters:
      #   filename
      #     A png or jpeg file containing a strip of characters.
      #
      #   style
      #     Any combination of FontStyle categories.
      #
      #   mapping
      #     A string of characters specifying the Unicode value of
      #     each character in the font strip.  The default is a
      #     string of 95 characters ranging from ' ' (space) to
      #     '~'.
      #
      # If you want to create a single font out of several different
      # font strips, use a FontBuilder instead.
      local FontBuilder builder( filename, style, mapping )
      init( builder.create_letter_map, builder.font_height )

    method init( Bitmap bitmap, FontStyle style=FontStyle.fixed_width,
      String mapping=String(' '..'~') ):

      local FontBuilder builder( bitmap, style, mapping )
      init( builder.create_letter_map, builder.font_height )

    method init( characters, height );
      # Initializes this font with an existing lookup table of 
      # Char->FontCharacter mappings and a font height.

    method height.Real64:
      # Height property-get.  Returns the original pixel height
      # times the y-scale value.
      return &height * scale.y

    method scaled( Vector2 new_scale ):
      # Scale property-set.
      &scale = new_scale

    method scaled( Real64 uniform_scale ):
      # Scale property-set.
      &scale = Vector2(uniform_scale,uniform_scale)

    method draw( String st, Vector2 pos ):
      # Draws the given string of characters to the screen with the
      # top-left corner of the first character at the given position.
      local Vector2 line_advance( 0, height )
      forEach (line in LineReader(st))
        draw_line( line, pos )
        pos += line_advance
      endForEach

    method draw_center( String st, Vector2 pos ):
      # Draws the given string to the screen with the
      # top-center of all the characters at the given position.
      local Vector2 line_advance( 0, height )
      forEach (line in LineReader(st))
        draw_line( line, pos - Vector2( text_width_of(line)/2, 0 ) )
        pos += line_advance
      endForEach

    method draw_center( String st, Vector2 pos, Real64 field_width ):
      # Draws the given string centered in the given
      # field width.  'pos' is the top-left corner of the field.
      pos += Vector2( field_width/2, 0 )
      local Vector2 line_advance( 0, height )
      forEach (line in LineReader(st))
        draw_line( line, pos - Vector2( text_width_of(line)/2, 0 ) )
        pos += line_advance
      endForEach

    method draw_right( String st, Vector2 pos, Real64 field_width ):
      # Draws the given string right-justified in a field with the
      # given top-left 'pos' and width.
      pos = Vector2( pos.x + field_width, pos.y )
      local Vector2 line_advance( 0, height )
      forEach (line in LineReader(st))
        draw_line( line, pos - Vector2( text_width_of(line), 0 ) )
        pos += line_advance
      endForEach

    method draw_right( String st, Vector2 pos ):
      # Draws the given string right-justified with its right
      # edge at 'pos'.
      local Vector2 line_advance( 0, height )
      forEach (line in LineReader(st))
        draw_line( line, pos - Vector2( text_width_of(line), 0 ) )
        pos += line_advance
      endForEach

    method draw_line( String st, Vector2 pos ):
      # Internal use.  Draws a single line of text with its top-left
      # corner at position 'pos'.
      local var x = pos.x
      local var y = pos.y
      forEach (ch in st)
        local var entry = characters.find( ch )
        if (entry isNot null)
          local FontCharacter letter = entry.value
          local Image img = letter.image
          img.color = color
          img.scale = scale
          img.draw( Vector2(x,y) )
          x += letter.width * scale.x
        endIf
      endForEach

    method text_width_of( String text ).Real64:
      # Returns the render width of 'text' in pixels, taking the
      # current scale into account.
      local Real64 total_width = 0.0
      forEach (ch in text)
        local var entry = characters.find( ch )
        if (entry isNot null)
          total_width += entry.value.width
        endIf
      endForEach
      return total_width * scale.x

    method text_width_of( Char ch ).Real64:
      # Returns the render width of 'ch' in pixels, taking the
      # current scale into account.
      local var entry = characters.find( ch )
      if (entry isNot null) return entry.value.width * scale.x
      else return 0.0
      
    method adjust_character_widths( Int32 amount ):
      # Adjusts the logical widths of all the characters in this
      # font.  A positive value will space characters further apart
      # while a negative value will scoot them closer together.
      forEach (ch in characters.values)
        ch.width += amount
        if (ch.width < 0) ch.width = 0
      endForEach

    method word_wrap( String st, Int32 pixel_width ).String[]:
      # Returns a word-wrapped version of this string as a list of lines.
      # Existing newlines characters will cause a new line to begin
      # immediately.  Spaces immediately following existing newline 
      # characters are preserved.
      local String[] lines()
      local Int32 i1=0, i2=0
      local Int32 len = st.count
      local Int32 w = 0

      while (i2 < len)

        # find last space or first \n
        while (w <= pixel_width and i2 < len and st[i2] != '\n')
          local var char_w = text_width_of(st[i2])
          w += char_w
          i2++
        endWhile

        local var initial_i2 = i2

        if (w >= pixel_width)
          if (i2 >= len)
            i2 = len
          else
            while (st[i2]!=' ' and st[i2]!='\n' and i2>i1) i2--
            if (i2 == i1) i2 = initial_i2
          endIf
        endIf

        lines.add( st.substring(i1,i2-1) )

        if (i2 == len)
          return lines
        else
          which (st[i2])
            case ' ':
              while (i2<len and st[i2]==' ') i2++
              if (i2<len and st[i2]=='\n') i2++

            case '\n':
              i2++
          endWhich
          i1 = i2
        endIf
      endWhile

      return lines

endClass

class FontBuilder
  # Utility class used to load fonts; used by class Font for loading
  # fonts with single font-strip images.  To load a font with a 
  # series of font-strip images you can use this class directly.
  #
  # Example:
  #   Say that "letters.png" contains 26 fixed-width letter images
  #   and "numbers.png" contains 10 fixed-with number images.
  #
  #   PROPERTIES
  #     my_font : Font
  #   ...
  #     local FontBuilder builder()
  #     builder.load( "letters.png", String('A'..'Z') )
  #     builder.load( "numbers.png", String('0'..'9') )
  #     my_font = builder.to_Font
  PROPERTIES
    letters(128)  : HashTable<<Char,Bitmap>>
    handles(128)  : HashTable<<Char,Vector2>>
    letter_widths(128) : HashTable<<Char,Int32>>
    max_width    : Int32
    font_height  : Int32
    style        : FontStyle

  METHODS
    method init( style=FontStyle.fixed_width );
      # Initializes an empty FontBuilder with the specified font style
      # applying to future load() calls.

    method init( String filename, style=FontStyle.fixed_width, 
        String mapping=String(' '..'~') ):
      # Initializes the FontBuilder to load the given font strip as
      # its initial contents.
      load( filename, mapping )

    method init( Bitmap bitmap, style=FontStyle.fixed_width, 
        String mapping=String(' '..'~') ):
      # Initializes the FontBuilder to load the given font strip as
      # its initial contents.
      load( bitmap, mapping )

    method load( String filename, String mapping=String(' '..'~') ):
      # Adds the characters from the given font strip to this font.
      load( Bitmap(filename), mapping )

    method load( Bitmap src, String mapping ):
      # Adds the characters from the given font strip to this font.
      if (style.includes(FontStyle.fixed_width))
        # fixed-width font strip
        local Int32   pixel_width = src.width / mapping.count
        local Vector2 pixel_size = Vector2( pixel_width, src.height )
        font_height = src.height
        local Vector2 src_pos
        local Vector2 src_delta( pixel_width, 0 )
        forEach (ch in mapping)
          local Bitmap letter_bmp = Bitmap( src, src_pos, pixel_size )
          letters[ch] = letter_bmp
          letter_widths[ch] = pixel_size.x
          if (pixel_size.x > max_width) max_width = pixel_size.x
          handles[ch] = adjust_edges( ch, letter_bmp )
          src_pos += src_delta
        endForEach
      else
        # proportional font strip
        local Int32 letter_start_x = 0
        local Int32 letter_height = src.height - 1
        font_height = letter_height
        forEach (ch in mapping)
          local Int32 letter_width = find_letter_width( src, letter_start_x )
          local Bitmap letter_bmp = Bitmap( src, Vector2(letter_start_x,1), Vector2(letter_width,letter_height) )
          letters[ch] = letter_bmp
          letter_widths[ch] = letter_width
          handles[ch] = adjust_edges( ch, letter_bmp )
          letter_start_x += letter_width
        endForEach
      endIf

    method find_letter_width( Bitmap bmp, Int32 letter_start_x ).Int32:
      # Internal use.
      local var start_color = bmp.data[ letter_start_x ]
      forEach (x in letter_start_x+1..bmp.width)
        if (bmp.data[x] != start_color) return (x - letter_start_x)
      endForEach
      return bmp.width - letter_start_x

    method adjust_edges( Char ch, Bitmap letter_bmp ).Vector2:
      # Internal use.
      local Vector2 handle(0,0)
      local Box used_region = letter_bmp.non_transparent_region
      handle = -used_region.position
      letter_bmp.set( Bitmap( letter_bmp, used_region ) )
      if (not style.includes(FontStyle.point_filter))
        letter_bmp.add_transparent_outline
        return handle + 1
      endIf
      return handle

    method to_Font.Font:
      # Returns a Font containing all the characters that have been
      # loaded by this FontBuilder.
      local Font font( create_letter_map, font_height )
      if (style.includes(FontStyle.snug)) font.adjust_character_widths( -1 )
      return font

    method create_letter_map.HashTable<<Char,FontCharacter>>:
      # Internal use.

      local HashTable<<Char,FontCharacter>> font_map(256,1)

      if (max_width <= 62 and font_height <= 62)
        # pack in the letters
        local TileLayout<<LetterLayoutInfo>> layout_manager(Vector2(62,62))
        local Int32 sheet_size = 62

        local LetterLayoutInfo[] tiles( 256 )

        forEach (ch in letters.keys) 
          tiles.add( LetterLayoutInfo(letters[ch].size, ch) )
        endForEach
        local var num_sheets = layout_manager.layout( tiles )

        # create the sheets
        local Bitmap[] sheets( num_sheets )
        forEach (index in 0..<num_sheets) sheets.add( Bitmap(sheet_size,sheet_size) )

        # copy each letter to its appropriate spot
        forEach (tile in tiles)
          letters[tile.ch].draw_to( sheets[tile.sheet_index], tile.rect.position, false )
        endForEach

        # create the font
        local Image[] images( sheets.count )
        forEach (bitmap in sheets) images.add( Image(bitmap) )
        forEach (tile in tiles)
          local Char ch = tile.ch
          local Image img( images[tile.sheet_index], tile.rect )
          img.handle = handles[ch]
          if (style.includes(FontStyle.point_filter)) 
            img.render_flags |= Render.point_filter
          else
            img.render_flags &= !Render.point_filter
          endIf
          font_map[ch] = FontCharacter( img, letter_widths[ch] )
        endForEach
        forEach (image in images) image.release

      else

        forEach (ch in letters.keys) 
          local Image img( letters[ch] )
          img.handle = handles[ch]
          if (style.includes(FontStyle.point_filter)) 
            img.render_flags |= Render.point_filter
          else
            img.render_flags &= !Render.point_filter
          endIf
          font_map[ch] = FontCharacter( img, letter_widths[ch] )
        endForEach

      endIf

      return font_map
endClass


class FontCharacter
  # Internal use.  Specifies information about a single font character.
  PROPERTIES
    image : Image
    width : Int32

  METHODS
    method init( image, width );
endClass


#=====================================================================
# Wii
#=====================================================================
singleton class Wii
  # Functionality specific to the Wii.  Check for 
  # System.os() == "wii" to determine if a game is actually running 
  # on the Wii before calling one of these methods.
  METHODS
    method enable_home_menu( Logical setting ): native
      # Enables or disables the Wii home menu.
      #
      # When the home menu is disabled, the application will get 
      # joystick button press events for the home button (button 10) 
      # but nothing else will happen.
      #
      # When the home menu is enabled, the application will get a
      # home button press event just before Plasmacore enters the
      # home menu state on the Wii.  While the home menu is displayed,
      # a Plasmacore game receives no further input and calls to
      # Application::update() are suspended.  When the home menu
      # is exited the application will get a home menu joystick button
      # release event.
      # 
      # The home menu is disabled upon application startup.

    method enable_pointer_mode( Logical setting ): native
      # Enables or disables pointer mode for the the Wii Remotes.
      #
      # When enabled, the application receives joystick movement events
      # on axes 4, 5, and 6 as well as mouse position events, all reflecting
      # the position the Wii Remote is pointing to on-screen (with joystick
      # axis 6 being the distance from the screen in meters).  The cost
      # is more of a power drain on the Wii Remote batteries.
      #
      # Your application should disable the pointer mode in game states where
      # the information is not required.
      #
      # Pointer mode is disabled by default.
endClass

#=====================================================================
# IPhone
#=====================================================================
requisite singleton class IPhone
  # Functionality specific to the iPhone.  Check for 
  # System.os() == "iphone" to determine if a game is actually running 
  # on the iPhone before calling any methods.
  PROPERTIES
    x_acceleration, y_acceleration, z_acceleration : Real64
    keyboard_visible : Logical

  METHODS
    method enable_auto_dimming( Logical setting ): native
      # Allows or prevents the iPhone from auto-dimming the screen
      # after a period of no touch interaction.  "true" (enabled)
      # by default.

    method orient( Int32 direction ): native
      # Orients the status bar & keyboard to 0=up, 1=right, 2=down, 3=left.

    method keyboard_visible( keyboard_visible ):
      native_keyboard_visible( &keyboard_visible )

    method native_keyboard_visible( Logical setting ): native
      # Shows or hides the keyboard.  Set the orientation with orient().

    method status_bar_visible( Logical setting ): native
      # Shows or hides the status bar on the iPhone.  "false"
      # by default.

    method vibrate: native
      # Causes the iPhone to vibrate briefly.  Nothing happens on 
      # non-iPhone platforms.

endClass


#=====================================================================
# SystemFont
#=====================================================================
deferred singleton class SystemFont : Font
  # A monospaced, 17 pixel-high font.
  METHODS
    method init:
      try
        local Font src( "font_system_17" )
        src.adjust_character_widths( -1 )
        height = src.height
        color  = src.color
        scale  = src.scale
        characters = src.characters
        #TextureSheetManager.update_textures
      catch (FileError err)
        System.exit_program( 1, "Failed to load image font_system_17" )
      endTry

endClass

#=====================================================================
# Box2D
#=====================================================================

#=====================================================================
# Box2D Compound Data types
#=====================================================================
compound Box2DTransform(Real64 x, Real64 y, Real64 c1x, Real64 c1y, Real64 c2x, Real64 c2y)
# A box2d transform contains position data and a 2x2 matrix. Mainly used by the debug renderer

compound Box2DBodyData( Vector2 world_center, Vector2 local_center, 
  Vector2 velocity,
	Real64 angular_velocity,
	Real64 mass,
	Real64 inertia,
	Logical is_bullet,
	Logical is_static,
	Logical is_dynamic,
	Logical is_frozen,
	Logical is_sleeping)
# Data associated with a body. Normally you'll only need
# x, y, and angle, but this data gives a complete snapshot of a body's state.

compound Box2DShapeGeometry(Int32 shape_type,
	Vector2 center, Real64 radius,
	Int32 num_vertices,
	Vector2 v0, Vector2 v1, Vector2 v2, Vector2 v3,
	Vector2 v4, Vector2 v5, Vector2 v6, Vector2 v7 )
# geometry data for a box2D shape.
# shape_type == 0 indicates circle. Use center and radius data
# shape_type == 1 indicated polygon. User vertex data.

compound Box2DMat22(Real64 c1x, Real64 c1y, Real64 c2x, Real64 c2y)
# a 2x2 Box2D matrix

requisite compound Box2DContactPoint(Int32 type,
	Int32 body1, Int32 body2,
	Int32 shape1, Int32 shape2,
  Vector2 position,
  Vector2 velocity,
  Vector2 normal,
	Real64 separation,
	Real64 friction,
	Real64 restitution,
	Int32 key)
# This structure is used to report contact points.
#   type: 0 = Add, 1 = Persist, 2 = Remove
#	shape1;		///< the first shape
#	shape2;		///< the second shape
#	position;		///< position in world coordinates
#	velocity;		///< velocity of point on body2 relative to point on body1 (pre-solver)
#	normal;			///< points from shape1 to shape2
#	separation;		///< the separation is negative when shapes are touching
#	friction;		///< the combined friction coefficient
#	restitution;	///< the combined restitution coefficient
#	key;			///< the contact key identifies this contact

requisite compound Box2DContactResult(Int32 body1, Int32 body2,
	Int32 shape1, Int32 shape2,
  Vector2 position,
  Vector2 normal,
	Real64 normal_impulse,
	Real64 tangent_impulse,
	Int32 key)
#   shape1;		///< the first shape
#	shape2;		///< the second shape
#	position;		///< position in world coordinates
#	normal;			///< points from shape1 to shape2
#	normal_impulse;	///< the normal impulse applied to body2
#	tangent_impulse;	///< the tangent impulse applied to body2
#	key;			///< the contact id identifies the features in contact

compound Box2DJointState(Int32 jointType,
		Int32 body1, Int32 body2,
		Vector2 anchor1, Vector2 anchor2,
		Vector2 reactionForce, Real64 reactionTorque,
		Real64 jointTranslation, Real64 jointSpeed, Radians jointAngle,
		Real64 length1, Real64 length2)
# jointType : the type of joint (0=unknown, 1=revolute, 2=prismatic, 3=distance, 4=pulley, 5=mouse(unused), 6=gear)
# body1, body2 : the indices of the bodies connected to the joint
# anchor1, anchor2 : The current position of the anchors, in world coords.
# reactionForce : the reaction force on body2 at the joint anchor.
# reactionTorque : the reaction torque on body2
# jointTranslation : The current translation of the joint (applies only to prismatic joints)
# joint speed : The speed of the joint. Applies to prismatic and revolute joints
# joint angle : The current angle of the joint. Applies only to revolute joints.
# length1, length2 : the current length of the sides


#=====================================================================
# NativeBox2D
#=====================================================================

requisite singleton class NativeBox2D
# Provides the native interface for Box2D

  PROPERTIES

    debug_draw_scale = 10.0 : Real64
    # the x and y scale factor to be used in the debug_render function

    debug_draw_translate = Vector2(0,0) : Vector2
    # translation to be used in the debug_render function

    contact_listener = null : Box2DContactListener
    # user-settable contact listener

  METHODS
    method debug_draw():
    # Testing method renders the shapes in the current box2D world using simple lines.
    
      local Int32 body_index = NativeBox2D.get_body_list()
      while(body_index > 0)
        # const b2XForm& xf = b->GetXForm()
        local Box2DTransform xf = NativeBox2D.body_get_xform(body_index)
      
        # trace("body $:" (body_index))
      
        local Box2DBodyData bodyData = NativeBox2D.body_get_data(body_index)
      
        local Int32 shapeIndex = NativeBox2D.body_get_shape_list(body_index);
        while(shapeIndex > 0)

          if (bodyData.is_static)
            debug_draw_shape(shapeIndex, xf, Color(0,128,0))
          elseIf(bodyData.is_sleeping)
            debug_draw_shape(shapeIndex, xf, Color(0,0,200))
          elseIf(bodyData.is_frozen)
            debug_draw_shape(shapeIndex, xf, Color(0,0,50))
          else
            debug_draw_shape(shapeIndex, xf, Color(255,255,255))
          endIf
      
          shapeIndex = NativeBox2D.shape_get_next(shapeIndex);
        endWhile
      
        body_index = NativeBox2D.body_get_next(body_index);
      endWhile
      #endMethod debug render

    method debug_draw_shape(Int32 shapeIndex, Box2DTransform xf, Color color):
    # draws a shape for debugging purposes
      local Box2DShapeGeometry geom = NativeBox2D.shape_get_geometry(shapeIndex)
    
      if (geom.shape_type == 0)
        #draw a circle
        local Vector2 center = multiply(xf, geom.center)
        local Real64 radius = geom.radius
        local Vector2 axis = Vector2(xf.c1x, xf.c1y)
      
        Circle(center * debug_draw_scale + debug_draw_translate, radius * debug_draw_scale).draw(color)
        Line(center * debug_draw_scale + debug_draw_translate, 
          (center + radius * axis) * debug_draw_scale + debug_draw_translate).draw(color)
    
      elseIf(geom.shape_type == 1)
        #draw a polygon
      
        local Vector2 lastEnd;
      
      #{
        #most retarded, brute force, method, ever!
        if (geom.numVertices >= 2)
          Line(multiply(xf, Vector2(geom.v0x, geom.v0y)) * debug_draw_scale + debug_draw_translate, 
                    multiply(xf, Vector2(geom.v1x, geom.v1y)) * debug_draw_scale + debug_draw_translate).draw(color)
          
          lastEnd = multiply(xf, Vector2(geom.v1x, geom.v1y)) * debug_draw_scale + debug_draw_translate
        endIf
      
        if (geom.numVertices >= 3)
          draw_line(multiply(xf, Vector2(geom.v1x, geom.v1y)) * debug_draw_scale + debug_draw_translate, 
                    multiply(xf, Vector2(geom.v2x, geom.v2y)) * debug_draw_scale + debug_draw_translate,
          color)
        
          lastEnd = multiply(xf, Vector2(geom.v2x, geom.v2y)) * debug_draw_scale + debug_draw_translate
        endIf
      
        if (geom.numVertices >= 4)
          draw_line(multiply(xf, Vector2(geom.v2x, geom.v2y)) * debug_draw_scale + debug_draw_translate, 
                    multiply(xf, Vector2(geom.v3x, geom.v3y)) * debug_draw_scale + debug_draw_translate,
          color)
        
          lastEnd = multiply(xf, Vector2(geom.v3x, geom.v3y)) * debug_draw_scale + debug_draw_translate
        endIf
      
        if (geom.numVertices >= 5)
          draw_line(multiply(xf, Vector2(geom.v3x, geom.v3y)) * debug_draw_scale + debug_draw_translate, 
                    multiply(xf, Vector2(geom.v4x, geom.v4y)) * debug_draw_scale + debug_draw_translate,
            color)
        
          lastEnd = multiply(xf, Vector2(geom.v4x, geom.v4y)) * debug_draw_scale + debug_draw_translate
        endIf
      
        if (geom.numVertices >= 6)
          draw_line(multiply(xf, Vector2(geom.v4x, geom.v4y)) * debug_draw_scale + debug_draw_translate, 
                    multiply(xf, Vector2(geom.v5x, geom.v5y)) * debug_draw_scale + debug_draw_translate,
            color)
        
        lastEnd = multiply(xf, Vector2(geom.v5x, geom.v5y)) * debug_draw_scale + debug_draw_translate
        endIf
      
        if (geom.numVertices >= 7)
          draw_line(multiply(xf, Vector2(geom.v5x, geom.v5y)) * debug_draw_scale + debug_draw_translate, 
                    multiply(xf, Vector2(geom.v6x, geom.v6y)) * debug_draw_scale + debug_draw_translate,
              color)
        
          lastEnd = multiply(xf, Vector2(geom.v6x, geom.v6y)) * debug_draw_scale + debug_draw_translate
        endIf
      
        if (geom.numVertices >= 8)
          draw_line(multiply(xf, Vector2(geom.v6x, geom.v6y)) * debug_draw_scale + debug_draw_translate, 
                    multiply(xf, Vector2(geom.v7x, geom.v7y)) * debug_draw_scale + debug_draw_translate,
          color)
        
          lastEnd = multiply(xf, Vector2(geom.v7x, geom.v7y)) * debug_draw_scale + debug_draw_translate
        endIf
      
        #draw the end
        draw_line(lastEnd, 
                    multiply(xf, Vector2(geom.v0x, geom.v0y)) * debug_draw_scale + debug_draw_translate,
          color)
    }#
      endIf
    
    #end method debug_draw_shape


    method multiply(Box2DTransform xf, Vector2 v).Vector2:
    # multiplies a transformation by a vector
      local Vector2 result1 = Vector2(xf.x, xf.y)
      local Vector2 result2 = multiply(Box2DMat22(xf.c1x, xf.c1y, xf.c2x, xf.c2y), v)
      return result1 + result2
    
    method multiply(Box2DMat22 a, Vector2 v).Vector2:
    # multiply a matrix by a vector
      return Vector2(a.c1x * v.x + a.c2x * v.y, a.c1y * v.x + a.c2y * v.y)
    

    
    #world--------------------------------------------------------------------------
    
    method world_construct( Corners corners, Vector2 gravity, Logical sleep): native
      # initialize the global physics world with top left bound, bottom right bound, gravity,
      # and Logical sleep (allows inactive objects to sleep)
      
    method world_destruct : native
    # clear the box2d physics world. Invalidates all objects associated with the world.
    
    method world_step( Real64 timeStep, Int32 iterations ): native
    # advance the world by timeStep (normally 1/60).
    # iterations is the accuracy of the simulation. A higher number is slower but more accurate.
    # Try starting with iterations = 10.
    
    
    method world_create_body( Vector2 position,
      Real64 angle,
      Real64 linear_damping, Real64 angular_damping,
      Logical allow_sleep, Logical is_sleeping,
      Logical fixed_rotation, Logical is_bullet).Int32 : native
    #Create a body at posx, posy. Returns the resource index of the body.
    #A body is static if its mass is 0. To make this body static,
    #only attach shapes with 0 density.
    
    method world_is_null.Logical : native
    # checks to see whether the Box2D world stored in the native layer is null
    # and needs to be initialized before use.
    
    method get_body_list.Int32 : native
    # returns the resource index of the first body in the box2D world.
    # using this and body_get_next, you can explore all the bodies, shapes, and joints in the world.
    # returns -1 if the world is null, there are no bodies (which there always should be)
    # or for a resource indexing error.
    
    method get_ground_body.Int32 : native
    # returns the resource index of the ground body
    
    method world_set_gravity( Vector2 gravity ) : native
    # sets the gravity of the world
    
    method world_create_distance_joint(Int32 body1, Int32 body2, 
        Vector2 anchor1, Vector2 anchor2, Logical collide_connected).Int32 : native
    # Create a distance joint between two bodies. Anchors are in world coordinates.
    
    method world_create_revolute_joint( Int32 body1, Int32 body2,
      Vector2 world_anchor,
      Logical enable_limit,
      Radians lower_angle,
      Radians upper_angle,
      Logical enable_motor,
      Real64 motor_speed,
      Real64 max_motor_torque,
      Logical collide_connected).Int32 : native
    # creates a revolute joint between two bodies, anchored at world_anchor.
    # You can optionally enable limits and a motor. 
    
    method world_create_prismatic_joint(Int32 body1, Int32 body2,
      Vector2 world_anchor,
      Vector2 world_axis,
      Logical enable_limit, Real64 lower_translation, Real64 upper_translation,
      Logical enable_motor, Real64 motor_speed, Real64 max_motor_force,
      Logical collide_connected ).Int32 : native
    # create a prismatic joint between two bodies, given an anchor point and an axis.
    
    method world_create_pulley_joint(Int32 body1, Int32 body2,
      Vector2 ground_anchor1,Vector2 ground_anchor2,
      Vector2 anchor1, Vector2 anchor2,
      Real64 max_length1, Real64 max_length2,
      Real64 ratio,
      Logical collide_connected).Int32 : native
    # create a pulley joint given 2 ground anchors and 2 anchors in bodies.
    
    method world_create_gear_joint(Int32 body1, Int32 body2,
      Int32 joint1, Int32 joint2,
      Real64 ratio,
      Logical collide_connected).Int32 : native
    # create a gear joint between two bodies connected to the ground with 2 joints.
    # The joints must be revolute or prismatic.
    
    method world_destroy_resource(Int32 resource_index) : native
    # removes a body, joint, or shape from the world and the resource list.
      
    
    #Body-------------------------------------------------------------------------------
    
    method body_attach_polygon(Int32 body_index,
      Real64 friction,
      Real64 restitution,
      Real64 density,
      Logical is_sensor,
      Int32 category_bits, Int32 mask_bits, Int32 group_index,
      Int32 num_vertices,
      Vector2 v0,
      Vector2 v1,
      Vector2 v2,
      Vector2 v3,
      Vector2 v4,
      Vector2 v5,
      Vector2 v6,
      Vector2 v7).Int32 : native
    # Attaches a polygon shape with up to 8 vertices to the body defined by body_index.
    # Returns the resource index of the shape. The polygon should be convex.
    # Shapes with density 0 will be static (as long as the other shapes on the body are also static)
    
    method body_attach_circle(Int32 body_index,
      Real64 friction,
      Real64 restitution,
      Real64 density,
      Logical is_sensor,
      Int32 category_bits,Int32 mask_bits,Int32 group_index,
      Vector2 center, Real64 radius).Int32 : native
    # Attaches a circle shape to the body defined by body_index.
    # Returns the resource index of the shape.
    # Shapes with density 0 will be static (as long as the other shapes on the body are also static)
    
    method body_get_position(Int32 body_index).Vector2 : native
    # returns the position of the body referenced by body_index
    
    method body_get_angle(Int32 body_index).Radians : native
    # returns the angle of the body referenced by body_index
    
    method body_get_next(Int32 body_index).Int32 : native
    # returns the next body in the world list.
    # returns <= 0 if there are no more bodies in the list (or on error)
    
    method body_get_xform(Int32 body_index).Box2DTransform : native
    # returns the transformation information for the body. Primarily
    # used by the debug rendering function.
    
    method body_get_shape_list(Int32 body_index).Int32 : native
    # returns the first in the list of shapes associated with the body
    
    method body_get_data(Int32 body_index).Box2DBodyData : native
    # return all state data (except position and angle) associated with a body
    
    method body_get_world_point(Int32 body_index, Vector2 local_point).Vector2 : native
    # converts a point in local coordinates to a point in world coordinates
    
    method body_get_local_point(Int32 body_index, Vector2 world_point).Vector2 : native
    # converts a point in world coordinates to a point in local coordinates
    
    method body_get_world_vector(Int32 body_index, Vector2 local_vector).Vector2 : native
    # converts a vector in local coordinates to a vector in world coordinates
    
    method body_get_local_vector(Int32 body_index, Vector2 world_vector).Vector2 : native
    # converts a vector in world coordinates to a vector in local coordinates
    
    method body_wakeup(Int32 body_index) : native
    # wakes up a body. Necessary, for example, if you change gravity and objects are sleeping.
    
    method body_set_xform(Int32 body_index, Vector2 position, Radians angle) : native
    # set the position and angle of the body
    
    method body_set_velocity(Int32 body_index, Vector2 linear_velocity, Real64 angular_velocity) : native
    # set the linear and angular velocity of the body
    
    method body_apply_force(Int32 body_index, 
      Vector2 force, Vector2 force_point, 
      Real64 torque, Vector2 impulse, Vector2 impulse_point) : native
    # apply force and/or torque and/or impulse to a body.

    #shape------------------------------------------------------------------------------
    method shape_get_next(Int32 shape_index).Int32 : native
    # get the next shape in the list. Returns <= 0 if there are no more shapes.
    
    method shape_get_geometry(Int32 shape_index).Box2DShapeGeometry : native
    # get the geometry for the shape specified by shape_index
    
    method shape_set_filter(Int32 shape_index, Int32 category_bits, Int32 mask_bits, Int32 group_index) : native
    # changes a shape's collision filtering
    
    
    #contact reporting--------------------------------------------------------------------
    method set_contact_listener(Box2DContactListener listener):
    # set the contact listener object. Should be a derivation of Box2DContactListener.
    # Note that this method does not handle dispatches to multiple listeners.
    # (calling this method replaces the old listener).
    # If you want to allow multiple objects to listen to contact results,
    # extend Box2DContactListener so that it stores a list of listeners that it reports events to.
      contact_listener = listener
    
    method contact_set_reporting(Logical report_add, Logical report_persist, Logical report_remove, Logical report_result) : native
    # use this method to set which circumstances contacts are reported for
    
    requisite method report_contact_point(Box2DContactPoint contact):
    # called by native code when a contact is reported
      if (contact_listener isNot null)
        contact_listener.report_contact_point(contact)
      endIf
        
    requisite method report_contact_result(Box2DContactResult contact):
    # called by native code when a contact result is reported
      if (contact_listener isNot null)
        contact_listener.report_contact_result(contact)
      endIf

    #joint----------------------------------------------------------------------------------
    method joint_get_state(Int32 joint_index).Box2DJointState : native
    # Get the current state of the joint
    
    method joint_set_limits(Int32 joint_index, Real64 lower, Real64 upper) : native
    # Set the upper and lower limits of a prismatic (meters) or revolute (radians) joint.
    
    method joint_set_motor(Int32 joint_index, Logical enable_motor, Real64 speed, Real64 max_force) : native
    # Set the state of a revolute or prismatic joint's motor.
    # For revolute joints, max_force is the maximum torque on the joint.
      
endClass #NativeBox2D



underlying aspect Box2DContactListener
# extend this class to handle box2D contact events.
  METHODS
    method set_reporting(Logical reportAdd, Logical reportPersist, Logical reportRemove, Logical reportResult) :
    # set which kinds of events to recieve. Sets flags at the native layer.
      NativeBox2D.contact_set_reporting(reportAdd,reportPersist,reportRemove,reportResult)
    
      
    method report_contact_point(Box2DContactPoint contact):
    # implement this method to receive contact points

    method report_contact_result(Box2DContactResult contact):
    # implement this method to receive contact results
endAspect

